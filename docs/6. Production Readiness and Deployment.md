# Prontidão de produção e implantação

## Adicionando Healthchecks do EF no BackEnd
1. Adicione uma referência para o pacote NuGet `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore` version `3.0.0`.
    > Isso pode ser feito pela linha de comando usando `dotnet add package Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore --version 3.0.0`
1. Adicione um DbContext para o *health check* no `Startup.cs` adicionando o seguinte código no `ConfigureServices`:
   ```csharp
   services.AddHealthChecks()
           .AddDbContextCheck<ApplicationDbContext>();
   ```
1. O *health check* é ativado modificando-se o `UseEndpoints` para fazer uma chamada para o `endpoints.MapHealthChecks("/health");`. Isso vai configurar o *health check* no *end point* `/health`.
1. Teste o end point navegando para `/health`, isso deve retornar o texto `Healthy`.

## Adicionando Healthchecks do EF no FrontEnd
1. Adicione uma referência para o pacote NuGet `Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore` version `3.0.0`.
    > Isso pode ser feito pela linha de comando usando `dotnet add package Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore --version 3.0.0`

    > Obs.: Os projetos `FrontEnd` e `BackEnd` tem versões diferentes desse pacote porque eles também referênciam versões diferentes do EntityFrameworkCore.
1. Adicione um DbContext para o *health check* no `Startup.cs` adicionando o seguinte código no `ConfigureServices`:
   ```csharp
   services.AddHealthChecks()
           .AddDbContextCheck<IdentityDbContext>();
   ```
1. O *health check* é ativado modificando-se o `UseEndpoints` para fazer uma chamada para o `endpoints.MapHealthChecks("/health");`. Isso vai configurar o *health check* no *end point* `/health`.
1. Teste o end point navegando para `/health`, isso deve retornar o texto `Healthy`.

## Adicionando um *health check* personalizado para testar a disponibilidade do BackEnd
1. Adicione um método `CheckHealthAsync` no `IApiClient`.
   ```c#
   public interface IApiClient
   {
       ...
       Task<bool> CheckHealthAsync();
   }
   ```
1. Implemente o método `CheckHealthAsync` adicionando o seguinte código:
    ```csharp
    public async Task<bool> CheckHealthAsync()
    {
        try
        {
            var response = await _httpClient.GetStringAsync("/health");

            return string.Equals(response, "Healthy", StringComparison.OrdinalIgnoreCase);
        }
        catch
        {
            return false;
        }
    }
    ```
1. Crie uma pasta `HealthChecks` na pasta raiz do projeto FrontEnd.
1. Crie um arquivo chamado `BackendHealthCheck.cs` com a seguinte implementação:
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;
    using FrontEnd.Services;
    using Microsoft.Extensions.Diagnostics.HealthChecks;

    namespace FrontEnd.HealthChecks
    {
        public class BackendHealthCheck : IHealthCheck
        {
            private readonly IApiClient _client;

            public BackendHealthCheck(IApiClient client)
            {
                _client = client;
            }

            public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default(CancellationToken))
            {
                if (await _client.CheckHealthAsync())
                {
                    return HealthCheckResult.Healthy();
                }

                return HealthCheckResult.Unhealthy();
            }
        }
    }
    ```
1. Registre o `BackendHealthCheck` no `ConfigureServices`:
    ```csharp
    services.AddHealthChecks()
            .AddCheck<BackendHealthCheck>("backend")
            .AddDbContextCheck<IdentityDbContext>();
    ```
1. Teste o *end point* navegando para `/health`, isso deve retornar o texto `Healthy`.

## Publicando localmente

https://docs.microsoft.com/en-us/aspnet/core/publishing/#publish-to-a-folder

## Publicando em Produção (No Azure App Service)

- [Visual Studio](https://docs.microsoft.com/en-us/aspnet/core/tutorials/publish-to-azure-webapp-using-vs)
- [Git](https://docs.microsoft.com/en-us/aspnet/core/publishing/azure-continuous-deployment)

## Publicando usando Docker

**Prerequisitos**

- [Docker for Windows](https://www.docker.com/docker-windows) or [Docker for Mac](https://www.docker.com/docker-mac)
- [Visual Studio Tools for Docker with ASP.NET Core](https://docs.microsoft.com/aspnet/core/host-and-deploy/docker/visual-studio-tools-for-docker)

### Usando o Visual Studio

Adicione suporte ao Docker no projeto **BackEnd** clicando com o botão direito do mouse no aquivo do projeto e escolhendo Add > Docker Support

Um novo projeto é adicionado na solução **docker-compose.dcproj** contendo os seguintes arquivos.

- .dockerignore
- docker-compose.yml
- docker-compose.override.yml

Um **Dockerfile** também é adicionado ao projeto **BackEnd**.

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build
WORKDIR /src
COPY ConferencePlanner.sln ./
COPY BackEnd/BackEnd.csproj BackEnd/
COPY ConferenceDTO/ConferenceDTO.csproj ConferenceDTO/
RUN dotnet restore -nowarn:msb3202,nu1503
COPY . .
WORKDIR /src/BackEnd
RUN dotnet build -c Release -o /app

FROM build AS publish
RUN dotnet publish -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "BackEnd.dll"]
```

Repita os mesmos passos para o projeto **FrontEnd**. O Dockerfile é adicionado ao projeto para ele.

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build
WORKDIR /src
COPY ConferencePlanner.sln ./
COPY FrontEnd/FrontEnd.csproj FrontEnd/
COPY ConferenceDTO/ConferenceDTO.csproj ConferenceDTO/
RUN dotnet restore -nowarn:msb3202,nu1503
COPY . .
WORKDIR /src/FrontEnd
RUN dotnet build -c Release -o /app

FROM build AS publish
RUN dotnet publish -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "FrontEnd.dll"]
```

O arquivo **docker-compose.yml** é atualizado para refletir que haverá dois projetos para *buildar* imagens.

```yaml
version: '3'

services:
  backend:
    image: backend
    build:
      context: .
      dockerfile: BackEnd/Dockerfile

  frontend:
    image: frontend
    build:
      context: .
      dockerfile: FrontEnd/Dockerfile
```

#### Linking / Networking

Na arquitetura anterior, haviam algumas definições e orquestração manual para iniciar e rodar as aplicações juntas.

- **BackEnd** testado para tipo de SO e para definir a aplicação para usar o SQL Server ou SQLite
- **FrontEnd** a aplicação tem a url da API definida no arquivo *appsetting.json*
- **BackEnd** a url 'hard coded' e a port - `http://localhost:56009`

Usando Docker, adicionando um container para o SQL Server e vinculando os containers no aquivo de composição simplifica isso.

#### Adicionando SQL Server

Abra o arquivo docker-compose.yml e adicione a seguinte entrada. *Veja que o $ é duplo por uma questão de formatação*

```yaml
  db:
    image: "microsoft/mssql-server-linux"
    environment:
      SA_PASSWORD: "ConferencePlanner1234$$"
      ACCEPT_EULA: "Y
```

Como a aplicação **BackEnd** tem que ter conectividade e não pode iniciar até que o container de banco de dados esteja pronto, adicione a entrada **depends_on** à definição do **backend** no arquivo de composição.

```yaml
  backend:
    image: backend
    build:
      context: .
      dockerfile: BackEnd/Dockerfile
    depends_on:
      - db
```

Por fim, altere a connection string do banco de dados no arquivo BackEnd\appsettings.json.

```javascript
  "ConnectionStrings": {
    "DefaultConnection": "Server=db;Initial Catalog=ConferencePlanner;User=sa;Password=ConferencePlanner1234$;MultipleActiveResultSets=true"
  }
```

##### Vinculando / Criando rede entre o FrontEnd e o BackEnd

No arquivo **docker-compose.yml**, adicione a sessão **links** na definição do **frontend**. Isso define o nome do *host* na rede do Docker permitindo que a aplicação web possa fazer chamadas na API por nome. `http://backend`

```yaml
  frontend:
    image: frontend
    build:
      context: .
      dockerfile: FrontEnd/Dockerfile
    links:
      - backend
```

Altere o valor do **ServiceUrl** no FrontEnd/appsetting.json

```javascript
{
  "ServiceUrl": "http://backend/",
```

Remova ou comente o `.UseUrls(http://localhost:56009)` no BackEnd\Program.cs.

Finalmente abra o arquivo **docker-compose.override.yml**. Altere as portas da entrada **backend** para `56009:80` e para o **frontend**, mude para `5001:80`

```yaml
version: '3'

services:
  backend:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "56009:80"

  frontend:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5001:80"
```

Alterando esses valores, a API ainda pode ser acessada via `http://localhost:56009`, possibilitando testes usando a UI do swagger. A aplicação web FrontEnd pode ser acessada em `http://localhost:5001`, porém ela se comunica comm a API via rede interna pelo nome de *host* **backend**.

#### Iniciando e debugando

Uma vez completas as alterações, pressione F5 para iniciar o processo de build e a aplicação em Docker. Depuração ainda está disponível em todos projetos, mas agora a aplicação está rodando em containers.

Alterações podem ser feitas nas páginas Razor e vistas imediatamente sem rebuilds, porém alterações em arquivoa *.cs exigem rebuilds.

### Usando VS Code ou outros editores

Crie e adicione o seguinte Dockerfile na aplicação BackEnd.

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build
WORKDIR /src
COPY ConferencePlanner.sln ./
COPY BackEnd/BackEnd.csproj BackEnd/
COPY FrontEnd/FrontEnd.csproj FrontEnd/
COPY ConferenceDTO/ConferenceDTO.csproj ConferenceDTO/
RUN dotnet restore
COPY . .
WORKDIR /src/BackEnd
RUN dotnet build -c Release -o /app

FROM build AS publish
RUN dotnet publish -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "BackEnd.dll"]

```

Crie e adicione o seguinte Dockerfile na aplicação BackEnd.

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0 AS build
WORKDIR /src
COPY ConferencePlanner.sln ./
COPY BackEnd/BackEnd.csproj BackEnd/
COPY FrontEnd/FrontEnd.csproj FrontEnd/
COPY ConferenceDTO/ConferenceDTO.csproj ConferenceDTO/
RUN dotnet restore
COPY . .
WORKDIR /src/FrontEnd
RUN dotnet build -c Release -o /app

FROM build AS publish
RUN dotnet publish -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "FrontEnd.dll"]

```

Na raiz da solução ConferencePlanner, adicione o seguinte arquivo **docker-compose.yml**.

```yaml
version: '3'

services:
  backend:
    image: backend
    build:
      context: .
      dockerfile: BackEnd/Dockerfile
    ports:
      - "56009:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    depends_on:
      - db

  frontend:
    image: frontend
    build:
      context: .
      dockerfile: FrontEnd/Dockerfile
    ports:
      - "5002:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    links:
      - backend

  db:
    image: "microsoft/mssql-server-linux"
    environment:
      SA_PASSWORD: "ConferencePlanner1234$$"
      ACCEPT_EULA: "Y"
```

#### Configuração SQL Server

Altere a string de conexão do banco de dados no arquivo BackEnd\appsettings.json.

```javascript
  "ConnectionStrings": {
    "DefaultConnection": "Server=db;Initial Catalog=ConferencePlanner;User=sa;Password=ConferencePlanner1234$;MultipleActiveResultSets=true"
  }
```

##### Vinculando / Criando rede entre o FrontEnd e o BackEnd

Altere o valor do **ServiceUrl** no FrontEnd/appsetting.json

```javascript
{
  "ServiceUrl": "http://backend/",
```

Remova ou comente o `.UseUrls(http://localhost:56009)` no BackEnd\Program.cs.

#### Buildando e rodando

- Faça o build das imagems Docker `docker-compose build`
- Execute `docker-compose up -d` para iniciar a aplicação
- Execute `docker-compose down` para parar a aplicação
- Abra a aplicação em <http://localhost:5002>

## Bônus

### Helm Chart

Um [helm chart](https://helm.sh/) está localizado em **/save-points/6-Deployment-docker/helm** permitindo o fazer deployment no cluster do Kubernetes usando `helm install ./workshop`.

#### values.yaml

Aqui, os valores para os modelos de serviço e implantação são definidos. As imagens e tags do Docker devem ser atualizadas para o nome do seu repositório nos campos `image` e` tag` para cada parte do aplicativo antes da implementação.

```yaml
db:
  replicaCount: 1
  name: db
  internalPort: 55555
  externalPort: 55555
  image: microsoft/mssql-server-linux
  tag: latest
  pullPolicy: IfNotPresent
  eula: ACCEPT_EULA
  eulaValue: \Y
  sa: SA_PASSWORD
  saValue: ConferencePlanner1234$
  restart: Always

frontend:
  replicaCount: 1
  name: frontend
  internalPort: 80
  externalPort: 80
  image: frontend
  tag: latest
  environment: Production
  pullPolicy: IfNotPresent
  restart: Always

backend:
  replicaCount: 1
  name: backend
  internalPort: 80
  externalPort: 80
  image: backend
  tag: latest
  environment: Production
  pullPolicy: IfNotPresent
  restart: Always
```

**Próximo**: [Sessão #7 - Desafios](7.%20Challenges.md) | **Anterior**: [Sessão #5 - Adicionar Agenda](5.%20Add%20personal%20agenda.md)
