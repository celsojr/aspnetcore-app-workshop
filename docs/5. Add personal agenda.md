# Adicionando inscrição para os participantes
Nesta sessão nós iremos adicionar recursos que rastreiam os participantes que se registraram no site e permitem que eles possam criar uma agenda pessoal.

## Adicionando o BackEnd dos participantes e o FrontEnd da associação com o usuário
1. Atualize o arquivo `AuthHelpers` na pasta `Infrastructure`, adicionando membros nas classes `AuthConstants` e `AuthnHelpers` para trabalhar com usuários participantes:
    ``` c#
    namespace FrontEnd.Infrastructure
    {
        public static class AuthConstants
        {
            public static readonly string IsAdmin = nameof(IsAdmin);
            public static readonly string IsAttendee = nameof(IsAttendee);
            public static readonly string TrueValue = "true";
        }
    }

    namespace System.Security.Claims
    {
        public static class AuthnHelpers
        {
            public static bool IsAdmin(this ClaimsPrincipal principal) =>
                principal.HasClaim(AuthConstants.IsAdmin, AuthConstants.TrueValue);

            public static void MakeAdmin(this ClaimsPrincipal principal) =>
                principal.Identities.First().MakeAdmin();

            public static void MakeAdmin(this ClaimsIdentity identity) =>
                identity.AddClaim(new Claim(AuthConstants.IsAdmin, AuthConstants.TrueValue));

            public static bool IsAttendee(this ClaimsPrincipal principal) =>
                principal.HasClaim(AuthConstants.IsAttendee, AuthConstants.TrueValue);

            public static void MakeAttendee(this ClaimsPrincipal principal) =>
                principal.Identities.First().MakeAttendee();

            public static void MakeAttendee(this ClaimsIdentity identity) =>
                identity.AddClaim(new Claim(AuthConstants.IsAttendee, AuthConstants.TrueValue));
        }
    }
    ```
1. Atualize a classe `ClaimsPrincipalFactory` na pasta `Areas/Identity` e adicione código no `GenerateClaimsAsync` que adiciona a claim `IsAttendee` se o usuário for registrado como um participante:
    ``` c#
    public class ClaimsPrincipalFactory : UserClaimsPrincipalFactory<User>
    {
        private readonly IApiClient _apiClient;

        public ClaimsPrincipalFactory(IApiClient apiClient, UserManager<User> userManager, IOptions<IdentityOptions> optionsAccessor)
            : base(userManager, optionsAccessor)
        {
            _apiClient = apiClient;
        }

        protected override async Task<ClaimsIdentity> GenerateClaimsAsync(User user)
        {
            var identity = await base.GenerateClaimsAsync(user);

            if (user.IsAdmin)
            {
                identity.MakeAdmin();
            }

            var attendee = await _apiClient.GetAttendeeAsync(user.UserName);
            if (attendee != null)
            {
                identity.MakeAttendee();
            }

            return identity;
        }
    }
    ```
1. Adicioine uma Página Razor `Welcome.cshtml` e um modelo de página `Welcome.cshtml.cs` na pasta `Pages`.
1. Adicione um formulário de inscrição de usuário no `Welcome.cshtml`:

    ```html
    @page
    @using ConferenceDTO
    @model WelcomeModel

    <h2>Welcome @User.Identity.Name</h2>
    <p>
        Register as an attendee to get access to cool features.
    </p>

    <form method="post">
        <div asp-validation-summary="All" class="text-danger"></div>
        <input asp-for="Attendee.UserName" value="@User.Identity.Name" type="hidden" />
        <div class="form-group">
            <label asp-for="Attendee.FirstName" class="control-label"></label>
            <div class="row">
                <div class="col-md-6">
                    <input asp-for="Attendee.FirstName" class="form-control" />
                </div>
            </div>
            <span asp-validation-for="Attendee.FirstName" class="text-danger"></span>
        </div>
        <div class="form-group">
            <label asp-for="Attendee.LastName" class="control-label"></label>
            <div class="row">
                <div class="col-md-6">
                    <input asp-for="Attendee.LastName" class="form-control" />
                </div>
            </div>
            <span asp-validation-for="Attendee.LastName" class="text-danger"></span>
        </div>
        <div class="form-group">
            <label asp-for="Attendee.EmailAddress" class="control-label"></label>
            <div class="row">
                <div class="col-md-6">
                    <input asp-for="Attendee.EmailAddress" class="form-control" />
                </div>
            </div>
            <span asp-validation-for="Attendee.EmailAddress" class="text-danger"></span>
        </div>
        <div class="form-group">
            <div class="">
                <button type="submit" class="btn btn-primary">Save</button>
            </div>
        </div>
    </form>
    @section Scripts {
        <partial name="_ValidationScriptsPartial" />
    }
    ```
1. Crie uma sub pasta `Models` dentro da pasta `pages`, crie uma classe chamada `Attendee.cs`, e então crie uma classse que adiciona exibição de informação específica de um participante
    
    ```csharp
    using System.ComponentModel;
    using System.ComponentModel.DataAnnotations;

    namespace FrontEnd.Pages.Models
    {
        public class Attendee : ConferenceDTO.Attendee
        {
            [DisplayName("First name")]
            public override string FirstName { get => base.FirstName; set => base.FirstName = value; }

            [DisplayName("Last name")]
            public override string LastName { get => base.LastName; set => base.LastName = value; }

            [DisplayName("Email address")]
            [DataType(DataType.EmailAddress)]
            public override string EmailAddress { get => base.EmailAddress; set => base.EmailAddress = value; }
        }
    }
    ```
1. Na `Welcome.cshtml.cs`, adicione lógica que associa o usuário logado a um participante:
    ```csharp
    using System.Threading.Tasks;
    using FrontEnd.Services;
    using FrontEnd.Pages.Models;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.AspNetCore.Mvc.RazorPages;
    using System.Security.Claims;
    using Microsoft.AspNetCore.Authentication;
    using Microsoft.AspNetCore.Identity;

    namespace FrontEnd.Pages
    {
        public class WelcomeModel : PageModel
        {
            private readonly IApiClient _apiClient;

            public WelcomeModel(IApiClient apiClient)
            {
                _apiClient = apiClient;
            }

            [BindProperty]
            public Attendee Attendee { get; set; }

            public IActionResult OnGet()
            {
                // Redirect to home page if user is anonymous or already registered as attendee
                var isAttendee = User.IsAttendee();

                if (!User.Identity.IsAuthenticated || isAttendee)
                {
                    return RedirectToPage("/Index");
                }

                return Page();
            }

            public async Task<IActionResult> OnPostAsync()
            {
                var success = await _apiClient.AddAttendeeAsync(Attendee);

                if (!success)
                {
                    ModelState.AddModelError("", "There was an issue creating the attendee for this user.");
                    return Page();
                }

                // Re-issue the auth cookie with the new IsAttendee claim
                User.MakeAttendee();
                await HttpContext.SignInAsync(IdentityConstants.ApplicationScheme, User);

                return RedirectToPage("/Index");
            }
        }
    }
    ```
1. Usuários logados agora podem ser associados a um participante ao visitar essa página.

## Adicione um middleware para forçar usuários logados a se cadastrarem na página de boas vindas
1. Adicione uma pasta chamada `Middleware`.
1. Adicione um novo atributo `SkipWelcomeAttribute.cs` para permitir que certas páginas ou métodos de ação (action methods) sejam ignorados para reforçar o redirecionamento para a página de boas vindas:
    
    ```csharp
    using System;

    namespace FrontEnd
    {
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
        public class SkipWelcomeAttribute : Attribute
        {

        }
    }
    ```
1. Adicione uma nova classe chamada `RequireLoginMiddleware.cs` que redireciona para a página de boas vindas se o usuário estiver autenticado mas não associado à um participante (não possuir a claim `IsAttendee`):

    ```csharp
    public class RequireLoginMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly LinkGenerator _linkGenerator;

        public RequireLoginMiddleware(RequestDelegate next, LinkGenerator linkGenerator)
        {
            _next = next;
            _linkGenerator = linkGenerator;
        }

        public Task Invoke(HttpContext context)
        {
            var endpoint = context.GetEndpoint();

            // If the user is authenticated but not a known attendee *and* we've not marked this page
            // to skip attendee welcome, then redirect to the Welcome page
            if (context.User.Identity.IsAuthenticated &&
                endpoint?.Metadata.GetMetadata<SkipWelcomeAttribute>() == null)
            {
                var isAttendee = context.User.IsAttendee();

                if (!isAttendee)
                {
                    var url = _linkGenerator.GetUriByPage(context, page: "/Welcome");
                    // No attendee registerd for this user
                    context.Response.Redirect(url);

                    return Task.CompletedTask;
                }
            }

            return _next(context);
        }
    }
    ```
1. Adicione o `RequireLoginMiddleware` no método `Configure` na `Startup.cs` antes do `UseEndpoints()`:

    ```csharp
    app.UseMiddleware<RequireLoginMiddleware>();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
    ```
1. Autalize a classe `Welcome.cshtml.cs` com o atributo para garantir que ele será ignorado quando o filtro global for executado:

    ```csharp
    [SkipWelcome]
    public class WelcomeModel : PageModel
    {
        ...
    ```
1. Isso deve garantir que todos os usuários logados se registrarão como participantes.

## Aplicando o scaffold e atualização na página de Logout
  > Um problema com o sistema acima é que se um novo usuário criar uma conta mas não se registrar como participante, ele não conseguirá sair. A solução geral para isso é adicionar a página `[SkipWelcome]` na view `Logout`, mas para fazer isso nós vamos precisar aplicar o scaffold nela. Páginas do Identity são fornecidas pelo pacote do NuGet Identity UI por padrão, mas elas podem ser adicionadas ao projeto para serem sobrescritas, como nós já vimos na página `Register`.
  
### Usando o Visual Studio
1. Clique com o botão direito no projeto `FrontEnd` e escolha *Add* / *New Scaffolded Item* / *Identity*.
1. Verifique a página `Account\Logout`, escolha o `IdentityDbContext` como *classe de dados de contexto*, e aperte *Add*.

### Usando a linha de comando
1. Execute este comando a partir da pasta do projeto **FrontEnd**.
```
dotnet aspnet-codegenerator identity --dbContext FrontEnd.Data.IdentityDbContext --files Account.Logout
```

### Continuando
1. Adicione o atributo `[SkipWelcome]` na classe `LogoutModel`:
    ```csharp
    [SkipWelcome]
    [AllowAnonymous]
    public class LogoutModel : PageModel
    {
        ...
    ```
1. Agora você conseguirá sair se você criar um novo usuário mas não se registrar como participante.

# Adicionando agenda pessoal

## Atualize o ApiClient
1. Adicione os seguintes métodos no `IApiClient`:
    
    ```csharp
    Task<List<SessionResponse>> GetSessionsByAttendeeAsync(string name);
    Task AddSessionToAttendeeAsync(string name, int sessionId);
    Task RemoveSessionFromAttendeeAsync(string name, int sessionId);
    ```
1. Adicione as implementações no `ApiClient`:

    ```csharp
    public async Task AddSessionToAttendeeAsync(string name, int sessionId)
    {
        var response = await _httpClient.PostAsync($"/api/attendees/{name}/session/{sessionId}", null);

        response.EnsureSuccessStatusCode();
    }

    public async Task RemoveSessionFromAttendeeAsync(string name, int sessionId)
    {
        var response = await _httpClient.DeleteAsync($"/api/attendees/{name}/session/{sessionId}");

        response.EnsureSuccessStatusCode();
    }

    public async Task<List<SessionResponse>> GetSessionsByAttendeeAsync(string name)
    {
        var response = await _httpClient.GetAsync($"/api/attendees/{name}/sessions");

        response.EnsureSuccessStatusCode();

        return await response.Content.ReadAsAsync<List<SessionResponse>>();
    }
    ```
### Adicione a API BackEnd para obter as sessões de um participante
1. Adicione uma ação chamada `GetSessions` no `AttendeesController` do projeto `BackEnd`:
    ```c#
    [HttpGet("{username}/sessions")]
    public async Task<ActionResult<List<SessionResponse>>> GetSessions(string username)
    {
        var sessions = await _context.Sessions.AsNoTracking()
                                            .Include(s => s.Track)
                                            .Include(s => s.SessionSpeakers)
                                                .ThenInclude(ss => ss.Speaker)
                                            .Where(s => s.SessionAttendees.Any(sa => sa.Attendee.UserName == username))
                                            .Select(m => m.MapSessionResponse())
                                            .ToListAsync();
        return sessions;
    }
    ```

## Adicione os botões Add/Remove na agenda pessoal da página de detalhes da Sessão
1. Adicione um propriedade `IsInPersonalAgenda` no `Session.cshtml.cs`:

    ```csharp
    public bool IsInPersonalAgenda { get; set; }
    ```
1. Compute o valor dessa propriedade no `OnGetAsync`:

    ```csharp
    if (User.Identity.IsAuthenticated)
    {
        var sessions = await _apiClient.GetSessionsByAttendeeAsync(User.Identity.Name);

        IsInPersonalAgenda = sessions.Any(s => s.Id == id);
    }
    ```
1. Adicione um formulário na parte inferior da página razor `Session.cshtml` que adiciona habilidade de adicionar/remover a sessão da agenda pessoal do participante:
    
    ```html
    <form method="post">
        <input type="hidden" name="sessionId" value="@Model.Session.Id" />
        <p>
            <a authz-policy="Admin" asp-page="/Admin/EditSession" asp-route-id="@Model.Session.Id" class="btn btn-default btn-sm">Edit</a>
            @if (Model.IsInPersonalAgenda)
            {
                <button authz="true" type="submit" asp-page-handler="Remove" class="btn btn-default btn-sm" title="Remove from my personal agenda">
                    <i class="icon ion-md-star" aria-hidden="true"></i>
                </button>
            }
            else
            {
                <button authz="true" type="submit" class="btn btn-default btn-sm bg-transparent" title="Add to my personal agenda">
                    <i class="icon ion-md-star-outline" aria-hidden="true"></i>
                </button>
            }
        </p>
    </form>
    ```
1. A marcação acima usa um ícone de estrela do [ionicons](https://ionicons.com/), uma das [coleções de ícones recomendadas pelo Bootstrap](https://getbootstrap.com/docs/4.0/extend/icons/). Vamos adicionar uma referência para um CDN para essa coleção no `Pages\Shared\_Layout.cshtml`, logo acima da referência `site.css`:
    ``` html
    </environment>
    <link rel="stylesheet" href="https://unpkg.com/ionicons@4.5.5/dist/css/ionicons.min.css" />
    <link rel="stylesheet" href="~/css/site.css" />
    ```
1. Adicione um manipulador `OnPostAsync` no `Session.cshtml.cs` que manipula a adição/remoção da sessão da agenda pessoal:

    ```csharp
    public async Task<IActionResult> OnPostAsync(int sessionId)
    {
        await _apiClient.AddSessionToAttendeeAsync(User.Identity.Name, sessionId);

        return RedirectToPage();
    }

    public async Task<IActionResult> OnPostRemoveAsync(int sessionId)
    {
        await _apiClient.RemoveSessionFromAttendeeAsync(User.Identity.Name, sessionId);

        return RedirectToPage();
    }
    ```
1. Participantes agora serão capazes de adicionar/remover sessões na agenda pessoal deles.

## Adicione a página MyAgenda
1. Adicione os arquivos `MyAgenda.cshtml` e `MyAgenda.cshtml.cs` na pasta `Pages`.
1. A página Index e a página MyAgenda compartilham a grande maioria da lógica e redenrização delas. Nós vamos refatorar a classe `Index.cshtml.cs` para que ela possa ser usada como uma classe base para a página `MyAgenda`.
1. Adicione um método `virtual` `GetSessionsAsync` no `Index.cshtml.cs`:

    ```csharp
    protected virtual Task<List<SessionResponse>> GetSessionsAsync()
    {
        return _apiClient.GetSessionsAsync();
    }
    ```
1. Altere o campo `_apiClient` no `Index.cshtml.cs` para ser `protected` ao invés de `private`:

    ```csharp
    protected readonly IApiClient _apiClient;
    ```
1. Altere a lógiac no `OnGetAsync` para retornar a sessão usando o novo método virtual que acabamos de adicionar:

    Before
    
    ```csharp
    var sessions = _apiClient.GetSessionsAsync();
    ```
    
    After
    
    ```csharp
    var sessions = await GetSessionsAsync();
    ```
1. Faça o modelo de página MyAgenda herdar do modelo de página Index. Altere o `MyAgenda.cshtml.cs` de forma similar como mostrado a seguir:

    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using ConferenceDTO;
    using FrontEnd.Services;
    using Microsoft.AspNetCore.Authorization;

    namespace FrontEnd.Pages
    {
        [Authorize]
        public class MyAgendaModel : IndexModel
        {
            public MyAgendaModel(IApiClient client)
                : base(client)
            {

            }

            protected override Task<List<SessionResponse>> GetSessionsAsync()
            {
                return _apiClient.GetSessionsByAttendeeAsync(User.Identity.Name);
            }
        }
    }
    ```
1. Refatore o `Index.cshtml` para `_AgendaPartial.cshtml` na pasta `Pages\Shared`. Essa view deve ter o seguinte conteúdo:
    ```html
    @model IndexModel

    <ul class="nav nav-pills mb-3">
    @foreach (var day in Model.DayOffsets)
    {
        <li role="presentation" class="nav-item">
            <a class="nav-link @(Model.CurrentDayOffset == day.Offset ? "active" : null)" asp-route-day="@day.Offset">@day.DayofWeek?.ToString()</a>
        </li>
    }
    </ul>

    <div class="agenda">
        @foreach (var timeSlot in Model.Sessions)
        {
            <h4>@timeSlot.Key?.ToString("HH:mm")</h4>
            <div class="row">
                @foreach (var session in timeSlot)
                {
                    <div class="col-md-3 mb-4">
                        <div class="card shadow session h-100">
                            <div class="card-header">@session.Track?.Name</div>
                            <div class="card-body">
                                <h5 class="card-title"><a asp-page="Session" asp-route-id="@session.Id">@session.Title</a></h5>
                            </div>
                            <div class="card-footer">
                                <ul class="list-inline mb-0">
                                    @foreach (var speaker in session.Speakers)
                                    {
                                        <li class="list-inline-item">
                                            <a asp-page="Speaker" asp-route-id="@speaker.Id">@speaker.Name</a>
                                        </li>
                                    }
                                </ul>
                                <form authz method="post">
                                <input type="hidden" name="sessionId" value="@session.Id" />
                                <p class="mb-0">
                                    <a authz-policy="Admin" asp-page="/Admin/EditSession" asp-route-id="@session.Id" class="btn btn-default btn-xs">Edit</a>
                                    @if (Model.UserSessions.Contains(session.Id))
                                    {
                                        <button type="submit" asp-page-handler="Remove" class="btn btn-default btn-sm bg-transparent" title="Remove from my personal agenda">
                                            <i class="icon ion-md-star" aria-hidden="true"></i>
                                        </button>
                                    }
                                    else
                                    {
                                        <button type="submit" class="btn btn-default btn-sm bg-transparent" title="Add to my personal agenda">
                                            <i class="icon ion-md-star-outline" aria-hidden="true"></i>
                                        </button>
                                    }
                                </p>
                                </form>
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
    </div>
    ```
1. Atualize a `Index.cshtml` para usar a nova `_AgendaPartial`. Substitua a div inteira com a classe css "agenda" alterando o trecho de código para o seguinte:
    ```html
    <h1 class="mb-4">My Conference @System.DateTime.Now.Year</h1>

    <partial name="_AgendaPartial" model="Model" />
    ```
1. A seguir, use a `_AgendaPartial` na página `MyAgenda.cshtml`.
    ```html
    @page
    @model MyAgendaModel
    @{
        ViewData["Title"] = "My Agenda";
    }

    @if (Model.ShowMessage)
    {
        <div class="alert alert-success alert-dismissible" role="alert">
            <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            @Model.Message
        </div>
    }

    <h1 class="mb-4">My Agenda - My Conference @System.DateTime.Now.Year</h1>

    <partial name="_AgendaPartial" model="Model" />
    ```

## Adicione o link My Agenda no Layout
1. Abra o arquivo de layout `_Layout.cshtml`.
1. Adicione um link que é exibido apenas para usuários autenticados abaixo do link `/Speakers`:

    ```html
    <div class="navbar-collapse collapse d-sm-inline-flex flex-sm-row-reverse">
        <partial name="_LoginPartial" />
        <ul class="navbar-nav flex-grow-1">
            <li class="nav-item">
                <a class="nav-link text-dark" asp-page="/Search">Search</a>
            </li>
            <li class="nav-item">
                <a class="nav-link text-dark" asp-area="" asp-page="/Index">Agenda</a>
            </li>
            <li class="nav-item">
                <a class="nav-link text-dark" asp-page="/Speakers">Speakers</a>
            </li>
            <li class="nav-item" authz="true">
                <a class="nav-link text-dark" asp-page="/MyAgenda">My Agenda</a>
            </li>
            <li class="nav-item">
                <a class="nav-link text-dark" asp-area="" asp-page="/Privacy">Privacy</a>
            </li>
        </ul>
    </div>
    ```

## Atualize o IndexModel para incluir as user Sessions
1. Adicione uma propriedade `UserSessions` no `IndexModel`:
    ```csharp
    public List<int> UserSessions { get; set; } = new List<int>();
    ```
1. Atualize o método `OnGet` para carregar a `UserSessions`:

    ```csharp
    public async Task OnGet(int day = 0)
    {
        CurrentDayOffset = day;

        if (User.Identity.IsAuthenticated)
        {
            var userSessions = await _apiClient.GetSessionsByAttendeeAsync(User.Identity.Name);
            UserSessions = userSessions.Select(u => u.Id).ToList();
        }

        var sessions = await GetSessionsAsync();
        //...
    ```
1. Adicione os seguintes dois métodos no `IndexModel` para manipular a adição e a remoção de sessões da sua agenda na página `Index`:
    ```csharp
    public async Task<IActionResult> OnPostAsync(int sessionId)
    {
        await _apiClient.AddSessionToAttendeeAsync(User.Identity.Name, sessionId);

        return RedirectToPage();
    }

    public async Task<IActionResult> OnPostRemoveAsync(int sessionId)
    {
        await _apiClient.RemoveSessionFromAttendeeAsync(User.Identity.Name, sessionId);

        return RedirectToPage();
    }
    ```
1. Execute a aplicação e teste o recurso de *logging* e o gerenciamento da sua agenda na página `Index`, detalhes individuais de sessões, e na página `My Agenda`.

**Próximo**: [Sessão #6 - Deployment](6.%20Production%20Readiness%20and%20Deployment.md) | **Anterior**: [Sessão #4 - Autenticação](4.%20Add%20auth%20features.md)
