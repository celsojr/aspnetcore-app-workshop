## Construindo o Front End
Nesta sessão, nós iremos adicionar o front end e o web site, com uma página inicial pública (anônima) exibindo a agenda da conferência.

## Adicione um projeto FrontEnd
> Começaremos criando o novo projeto front end para o web site.

### Adicionando o projeto FrontEnd usando o Visual Studio
1. Se estiver no Visual Studio, clique com o botão direito na Solução e escolha *Add* / *New Project...*.
1. Escolha *.NET Core* como tipo de projeto na esquerda e escolha o template *ASP.NET Core Web Application*. Dê o nome "FrontEnd" ao projeto, dê o nome "ConferencePlanner" à solução, e aperte OK.
1. Escolha *ASP.NET Core 3.0* na lista da caixa de seleção no canto superior esquerdo
1. Escolha o template *Web Application* e clique em *OK*
![](images/vs2019-new-razorpages-project.png)
1. Clique com o botão direito no projeto *FrontEnd* e adicione uma referência para o projeto *ConferenceDTO*.

### Adicionando o projeto FrontEnd via linha de comando
1. Abra o prompt de comando e navegue até o diretório raiz `ConferencePlanner`.
1. Execute o seguinte comando:
   ```console
   dotnet new webapp -o FrontEnd
   ```
1. A seguir iremos adicionar uma referência para o projeto ConferenceDTO no novo projeto FrontEnd. Na linha de comando, navegue até o diretório do projeto e execute o seguinte comando:
   ```console
   dotnet add reference ../ConferenceDTO/ConferenceDTO.csproj
   ```

## Apague coisas desnecessárias
> Vamos limpar algumas coisas no template que nós não precisamos
1. Abra */Pages/Index.cshtml* e apague todo o conteúdo HTML (após a linha 6)

## Criar e conectar um serviço de cliente de API
> Vamos criar uma classe para falar com a nossa web API de serviço no backend

### Crie a classe cliente de serviço de API
1. Crie uma pasta chamada *Services* na raiz do projeto
1. Nessa pasta, adicione uma nova interface chamada `IApiClient` com os seguintes membros:
   ``` csharp
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using System.Threading.Tasks;
   using ConferenceDTO;

   namespace FrontEnd.Services
   {
       public interface IApiClient
       {
          Task<List<SessionResponse>> GetSessionsAsync();
          Task<SessionResponse> GetSessionAsync(int id);
          Task<List<SpeakerResponse>> GetSpeakersAsync();
          Task<SpeakerResponse> GetSpeakerAsync(int id);
          Task PutSessionAsync(Session session);
          Task<bool> AddAttendeeAsync(Attendee attendee);
          Task<AttendeeResponse> GetAttendeeAsync(string name);
          Task DeleteSessionAsync(int id);
       }
   }
   ```
1. Adicione uma referência para o pacote Nuget *Microsoft.AspNet.WebApi.Client* no projeto FrontEnd:
   ```
   dotnet add package Microsoft.AspNet.WebApi.Client
   ```
1. Ainda nessa pasta, adicione uma nova classe chamada `ApiClient` que implementa a interface `IApiClient` usando `HttpClient` para chamar a nossa aplicação API BackEnd e serializar/deserializar os payloads em JSON:
   ``` csharp
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using System.Net;
   using System.Net.Http;
   using System.Threading.Tasks;
   using ConferenceDTO;

   namespace FrontEnd.Services
   {
       public class ApiClient : IApiClient
       {
           private readonly HttpClient _httpClient;

           public ApiClient(HttpClient httpClient)
           {
               _httpClient = httpClient;
           }

           public async Task<bool> AddAttendeeAsync(Attendee attendee)
           {
               var response = await _httpClient.PostAsJsonAsync($"/api/attendees", attendee);
                
               if (response.StatusCode == HttpStatusCode.Conflict)
               {
                   return false;
               }

               response.EnsureSuccessStatusCode();
                
               return true;
           }

           public async Task<AttendeeResponse> GetAttendeeAsync(string name)
           {
               if (string.IsNullOrEmpty(name))
               {
                   return null;
               }

               var response = await _httpClient.GetAsync($"/api/attendees/{name}");

               if (response.StatusCode == HttpStatusCode.NotFound)
               {
                   return null;
               }

               response.EnsureSuccessStatusCode();

               return await response.Content.ReadAsAsync<AttendeeResponse>();
           }

           public async Task<SessionResponse> GetSessionAsync(int id)
           {
               var response = await _httpClient.GetAsync($"/api/sessions/{id}");

               if (response.StatusCode == HttpStatusCode.NotFound)
               {
                   return null;
               }

               response.EnsureSuccessStatusCode();

               return await response.Content.ReadAsAsync<SessionResponse>();
           }

           public async Task<List<SessionResponse>> GetSessionsAsync()
           {
               var response = await _httpClient.GetAsync("/api/sessions");

               response.EnsureSuccessStatusCode();

               return await response.Content.ReadAsAsync<List<SessionResponse>>();
           }

           public async Task DeleteSessionAsync(int id)
           {
               var response = await _httpClient.DeleteAsync($"/api/sessions/{id}");

               if (response.StatusCode == HttpStatusCode.NotFound)
               {
                   return;
               }

               response.EnsureSuccessStatusCode();
           }

           public async Task<SpeakerResponse> GetSpeakerAsync(int id)
           {
               var response = await _httpClient.GetAsync($"/api/speakers/{id}");

               if (response.StatusCode == HttpStatusCode.NotFound)
               {
                   return null;
               }

               response.EnsureSuccessStatusCode();

               return await response.Content.ReadAsAsync<SpeakerResponse>();
           }

           public async Task<List<SpeakerResponse>> GetSpeakersAsync()
           {
               var response = await _httpClient.GetAsync("/api/speakers");

               response.EnsureSuccessStatusCode();

               return await response.Content.ReadAsAsync<List<SpeakerResponse>>();
           }

           public async Task PutSessionAsync(Session session)
           {
               var response = await _httpClient.PutAsJsonAsync($"/api/sessions/{session.Id}", session);

               response.EnsureSuccessStatusCode();
           }
       }
   }
   ```

### Configure a API no cliente

1. Abra o arquivo *Startup.cs*
1. Localize o método `ConfigureServices` e adicione o seguinte código na parte inferior dele:

   ``` csharp
   services.AddHttpClient<IApiClient, ApiClient>(client =>
   {
       client.BaseAddress = new Uri(Configuration["serviceUrl"]);
   });
   ```

1. Isso adiciona uma instância do `HttpClientFactory` com o seu URL base obtido a partir da configuração da aplicação, o qual apontará para a nossa aplicação BackEnd API
1. Abra o arquivo *appsettings.json* e adicione a chave de configuração para `serviceUrl` apontando para a URL de acesso em que a sua aplicação API BackEnd específica está configurada (verifique o arquivo *launchSettings.json* para saber a porta específica que a sua aplicativo API BackEnd usa):

   ``` json
   "ServiceUrl": "https://localhost:56009/"
   ```

## Liste as sessões na página inicial

>Agora que temos um cliente de API que podemos usar para conversar com nossa aplicação API BackEnd, atualizaremos a página inicial para mostrar uma lista básica de todas as sessões da conferência para garantir que o FrontEnd possa conversar corretamente com o BackEnd.

### Carregue os dados na PageModel

1. Abra o arquivo */Pages/Index.cshtml.cs*
1. Edite o construtor para receber a interface `IApiClient` e atribua ela a uma campo local:

   ``` csharp
   protected readonly IApiClient _apiClient;

   public IndexModel(IApiClient apiClient)
   {
       _apiClient = apiClient;
   }
   ```

1. Adicione algumas propriedades para armazenar sessões e outros dados que precisaremos ao renderizar a página:

   ``` csharp
   public IEnumerable<IGrouping<DateTimeOffset?, SessionResponse>> Sessions { get; set; }

   public IEnumerable<(int Offset, DayOfWeek? DayofWeek)> DayOffsets { get; set; }

   public int CurrentDayOffset { get; set; }
   ```

1. Adicione um método de manipulação de página para manipular requisições do tipo GET na página, isso carrega os dados da sessão e calcula os dados necessários para montar a UI de navegação do dia:

   ``` csharp
   public async Task OnGet(int day = 0)
   {
       CurrentDayOffset = day;

       var sessions = await _apiClient.GetSessionsAsync();

       var startDate = sessions.Min(s => s.StartTime?.Date);

       var offset = 0;
       DayOffsets = sessions.Select(s => s.StartTime?.Date)
                            .Distinct()
                            .OrderBy(d => d)
                            .Select(day => (offset++, day?.DayOfWeek));

       var filterDate = startDate?.AddDays(day);

       Sessions = sessions.Where(s => s.StartTime?.Date == filterDate)
                          .OrderBy(s => s.TrackId)
                          .GroupBy(s => s.StartTime)
                          .OrderBy(g => g.Key);
   }
   ```

### Renderizar a lista de sessões na página inicial

1. Abra a página Razor */Pages/Index.cshtml*
1. Adicione algumas marcações Razor para exibir as sessões como uma lista simples, agrupada por time-slot:

   ``` html
   <div class="agenda">
       <h1>My Conference @System.DateTime.Now.Year</h1>

       @foreach (var timeSlot in Model.Sessions)
       {
           <h4>@timeSlot.Key?.ToString("HH:mm")</h4>
           <ul>
               @foreach (var session in timeSlot)
               {
                   <li>@session.Title</li>
               }
           </ul>
       }
   </div>
   ```
1. Clique com o botão direito na solução, escolha Propriedades e defina ambos os projetos BackEnd e FrontEnd como projetos de inicialização (startup projects)
1. Executando a aplicação FrontEnd nesse ponto, podemos ver que as sessões são listadas na página inicial

### Adicione botões que permitem exebir as sessões em dias diferentes

1. Na */Pages/Index.cshtml*, adicione algumas marcações para permitir que o usuário exiba sessões para dias diferentes da conferência, abaixo do `<h1>` que adicionamos anteriormente:

   ``` html
   <ul class="nav nav-pills mb-3">
       @foreach (var day in Model.DayOffsets)
       {
           <li role="presentation" class="nav-item">
               <a class="nav-link @(Model.CurrentDayOffset == day.Offset ? "active" : null)" asp-route-day="@day.Offset">@day.DayofWeek?.ToString()</a>
           </li>
       }
   </ul>
   ```

1. Execute a aplicação novamente e tente clicar nos botões para exibir sessões para dias diferentes

## Atualize a UI de lista de sessões

1. Melhore a aparência da lista de sessões atualizando a marcação para usar os [cards do Bootstrap](https://getbootstrap.com/docs/4.0/components/card/):

   ``` html
   <h4>@timeSlot.Key?.ToString("HH:mm")</h4>
   <div class="row">
   @foreach (var session in timeSlot)
    {
        <div class="col-md-3 mb-4">
            <div class="card shadow session h-100">
                <div class="card-header">@session.Track?.Name</div>
                <div class="card-body">
                    <h5 class="card-title"><a asp-page="Session" asp-route-id="@session.Id">@session.Title</a></h5>
                </div>
                <div class="card-footer">
                    <ul class="list-inline mb-0">
                        @foreach (var speaker in session.Speakers)
                        {
                            <li class="list-inline-item">
                                <a asp-page="Speaker" asp-route-id="@speaker.Id">@speaker.Name</a>
                            </li>
                        }
                    </ul>
                </div>
            </div>
        </div>
    }
   </div>
   ```

1. Execute a página novamente e veja a UI da lista de sessões atualizada. Clique nos botões novamente para exibir sessões para dias diferentes.

## Adicione uma página de detalhes das sessões
> Agora que temos uma página inicial exibindo todas as sessões, vamos criar uma página para exibir todos os detalhes de uma sessão específica

### Adicione uma página Razor Sessões
1. Adicione uma nova Página Razor usando o template *Razor Page*. Vamos chamar essa nova página de *Session.cshtml* e salva-la no diretório */Pages*.
1. Abra o *Session.cshtml.cs* e altere a classe de modelo de página para `SessionModel`.
1. Aceite o `IApiClient` no construtor e adicione membros de suporte para o modelo de Página `SessionModel`:
   ``` csharp
   public class SessionModel : PageModel
   {
       private readonly IApiClient _apiClient;

       public SessionModel(IApiClient apiClient)
       {
           _apiClient = apiClient;
       }

       public SessionResponse Session { get; set; }

       public int? DayOffset { get; set; }
   }
   ```
1. Adicione um método manipulador de página para recuperar os detalhes da Session e defini-los no modelo:
   ``` csharp
   public async Task<IActionResult> OnGetAsync(int id)
   {
       Session = await _apiClient.GetSessionAsync(id);

       if (Session == null)
       {
           return RedirectToPage("/Index");
       }

       var allSessions = await _apiClient.GetSessionsAsync();

       var startDate = allSessions.Min(s => s.StartTime?.Date);

       DayOffset = Session.StartTime?.Subtract(startDate ?? DateTimeOffset.MinValue).Days;

        return Page();
    }
   ```
1. Abra o arquivo *Session.cshtml* e adicione marcação para exibir os detalhes e UI de navegação:
   ``` html
   @page "{id}"
   @model SessionModel

   <ol class="breadcrumb">
       <li class="breadcrumb-item"><a asp-page="/Index">Agenda</a></li>
       <li class="breadcrumb-item"><a asp-page="/Index" asp-route-day="@Model.DayOffset">Day @(Model.DayOffset + 1)</a></li>
       <li class="breadcrumb-item active">@Model.Session.Title</li>
   </ol>

   <h1>@Model.Session.Title</h1>
   <span class="label label-default">@Model.Session.Track?.Name</span>

   @foreach (var speaker in Model.Session.Speakers)
   {
       <em><a asp-page="Speaker" asp-route-id="@speaker.Id">@speaker.Name</a></em>
   }

    @foreach (var para in Model.Session.Abstract.Split("\r\n", StringSplitOptions.RemoveEmptyEntries))
    {
       <p>@para</p>
    }
   ```

## Adicione uma página para exibir os detalhes do speaker
>Vamos adicionar uma página para exibir os detalhes para um determinado speaker

1. Adicione um nova Página Razor usando o template *Razor Page*. Chame a págna de *Speaker.cshtml* e salve-a no diretório */Pages*.
1. Aceite o `IApiClient` no contrutor e adicione membros de suporte para o modelo de Página `SpeakerModel`:
   ``` csharp
   public class SpeakerModel : PageModel
   {
       private readonly IApiClient _apiClient;

       public SpeakerModel(IApiClient apiClient)
       {
           _apiClient = apiClient;
       }

       public SpeakerResponse Speaker { get; set; }
   }
   ```
1. Adicione um método de manipulação de página para recuperar os detalhes do Speaker e defini-los no modelo:
   ``` csharp
   public async Task<IActionResult> OnGet(int id)
   {
       Speaker = await _apiClient.GetSpeakerAsync(id);

       if (Speaker == null)
       {
           return NotFound();
       }

       return Page();
   }
   ```
1. Abra o arquivo *Speaker.cshtml* e adicione marcação para exibir os detalhes e UI de navegação:
   ``` html
   @page "{id}"
   @model SpeakerModel

   <ol class="breadcrumb">
       <li class="breadcrumb-item"><a asp-page="/Speakers">Speakers</a></li>
       <li class="breadcrumb-item active">@Model.Speaker.Name</li>
   </ol>

   <h2>@Model.Speaker.Name</h2>

   <p>@Model.Speaker.Bio</p>

   <h3>Sessions</h3>
   <div class="row">
       <div class="col-md-5">
           <ul class="list-group">
               @foreach (var session in Model.Speaker.Sessions)
               {
                   <li class="list-group-item"><a asp-page="Session" asp-route-id="@session.Id">@session.Title</a></li>
               }
           </ul>
       </div>
   </div>
   ```

## Adicione funcionalidade de buscas
>Vamos adicionar uma página que permita que o usuário realize buscas na agenda da conferência, encontrando sessões e palestrantes que correspondam aos termos da pesquisa.
### Adicione os DTOs para as buscas
1. Adicione uma nova classe DTO `SearchTerm` no projeto de DTO:
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Text;

    namespace ConferenceDTO
    {
        public class SearchTerm
        {
            public string Query { get; set; }
        }
    }
    ```
1. Adicione uma nova classe DTO `SearchResult` no projeto de DTO:
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.Text;

   namespace ConferenceDTO
   {
       public class SearchResult
       {
            public SearchResultType Type { get; set; }

            public SessionResponse Session { get; set; }

            public SpeakerResponse Speaker { get; set; }
        }

        public enum SearchResultType
        {
            Session,
            Speaker
        }
   }
   ```

### Adicione um controller de busca
1. Adicione um `SearchController` com um método de ação (action method) que aceita um termo de pesquisa `SearchTerm` e busca por sessões e palestrantes com títulos ou nomes correspondentes.
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using System.Threading.Tasks;
   using BackEnd.Data;
   using ConferenceDTO;
   using Microsoft.AspNetCore.Mvc;
   using Microsoft.EntityFrameworkCore;

   namespace BackEnd.Controllers
   {
       [Route("api/[controller]")]
       [ApiController]
       public class SearchController : ControllerBase
       {
           private readonly ApplicationDbContext _context;

           public SearchController(ApplicationDbContext context)
           {
               _context = context;
           }

           [HttpPost]
           public async Task<ActionResult<List<SearchResult>>> Search(SearchTerm term)
           {
               var query = term.Query;
               var sessionResults = await _context.Sessions.Include(s => s.Track)
                                                   .Include(s => s.SessionSpeakers)
                                                       .ThenInclude(ss => ss.Speaker)
                                                   .Where(s =>
                                                       s.Title.Contains(query) ||
                                                       s.Track.Name.Contains(query)
                                                   )
                                                   .ToListAsync();

               var speakerResults = await _context.Speakers.Include(s => s.SessionSpeakers)
                                                       .ThenInclude(ss => ss.Session)
                                                   .Where(s =>
                                                       s.Name.Contains(query) ||
                                                       s.Bio.Contains(query) ||
                                                       s.WebSite.Contains(query)
                                                   )
                                                   .ToListAsync();

               var results = sessionResults.Select(s => new SearchResult
               {
                   Type = SearchResultType.Session,
                   Session = s.MapSessionResponse()
               })
               .Concat(speakerResults.Select(s => new SearchResult
               {
                   Type = SearchResultType.Speaker,
                   Speaker = s.MapSpeakerResponse()
               }));

               return results.ToList();
           }
       }
   }
   ```

### Adicione métodos de busca na IApiClient
1. Adicione o método `SearchAsync` para o IApiClient:
   ```csharp
   Task<List<SearchResult>> SearchAsync(string query);
   ```
1. Adicione a implementação para o ApiClient:
   ```csharp
   public async Task<List<SearchResult>> SearchAsync(string query)
   {
       var term = new SearchTerm
       {
           Query = query
       };

       var response = await _httpClient.PostAsJsonAsync($"/api/search", term);

       response.EnsureSuccessStatusCode();

       return await response.Content.ReadAsAsync<List<SearchResult>>();
   }
   ```

### Adicioine um página de buscas no Front End
1. Adicione uma nova Página Razor usando o template *Razor Page*. Chame a página de *Search.cshtml* e salve-a no diretório */Pages*.
1. Aceite o `IApiClient` no construtor e adicione membros de suporte para a Página modelo `SearchModel`:
   ``` csharp
   public class SearchModel : PageModel
   {
       private readonly IApiClient _apiClient;

       public SearchModel(IApiClient apiClient)
       {
           _apiClient = apiClient;
       }

       public string Term { get; set; }

       public List<SearchResult> SearchResults { get; set; }
   }
   ```
1. Adicione um método manipulador página para recuperar os resultados de busca e atribuí-los ao modelo, deserializando os itens de busca individuais para o tipo de modelo correspondente:
   ``` csharp
   public async Task OnGetAsync(string term)
   {
       Term = term;
       SearchResults = await _apiClient.SearchAsync(term);
   }
   ```
1. Abra o arquivo *Search.cshtml* e adicione marcação para permitir que os usuários digitem um termo de busca e exibam os resultados, transformando cada resultado no tipo de modelo correspondente:
   ``` html
   @page
   @using ConferenceDTO
   @model SearchModel

   <div class="search">
       <h1>Search</h1>
       <form method="get">
           <div class="input-group mb-3">
               <input asp-for="Term" placeholder="Search for sessions or speakers..." class="form-control" />
               <div class="input-group-append">
                   <button class="btn btn-outline-secondary" type="submit">Go!</button>
               </div>
           </div>
           @if (Model.SearchResults?.Count > 0)
           {
               <p>
                   @Model.SearchResults.Count result(s)
               </p>
           }
       </form>
   </div>

   <div class="row">
       @foreach (var result in Model.SearchResults)
       {
           <div class="col-md-12">
               @switch (result.Type)
               {
                   case SearchResultType.Speaker:
                       <div class="card shadow mb-3">
                           <div class="card-header">
                               <h3 class="card-title">Speaker: <a asp-page="Speaker" asp-route-id="@result.Speaker.Id">@result.Speaker.Name</a></h3>
                           </div>
                           <div class="card-body">
                               <p>
                                   @foreach (var session in result.Speaker.Sessions)
                                   {
                                       <a asp-page="/Session" asp-route-id="@session.Id"><em>@session.Title</em></a>
                                   }
                               </p>
                               <p>
                                   @result.Speaker.Bio
                               </p>
                           </div>
                       </div>
                       break;

                   case SearchResultType.Session:
                       <div class="card shadow mb-3">
                           <div class="card-header">
                               <h3 class="card-title">Session: <a asp-page="Session" asp-route-id="@result.Session.Id">@result.Session.Title</a></h3>
                               @foreach (var speaker in result.Session.Speakers)
                               {
                                   <a asp-page="/Speaker" asp-route-id="@speaker.Id"><em>@speaker.Name</em></a>
                               }
                           </div>
                           <div class="card-body">
                               <p>
                                   @result.Session.Abstract
                               </p>
                           </div>
                       </div>
                       break;
               }
           </div>
       }
   </div>
   ```
1. Adicione o link de busca no painel de navegação no `_Layout.cshtml`:
    ```html
    <li class="nav-item">
        <a class="nav-link text-dark" asp-page="/Search">Search</a>
    </li>
    ```
1. Clique no link `Search` para testar a novo recurso de busca.

**Próximo**: [Sessão #4 - Autenticação](4.%20Add%20auth%20features.md) | **Anterior**: [Sessão #2 - Back-end](2.%20Build%20out%20BackEnd%20and%20Refactor.md)
