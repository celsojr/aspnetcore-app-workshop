

## Construindo o Back End

Nesta sessão, nós iremos adicionar o resto dos nossos modelos e controllers que os expõem. Nós também iremos refatorar a nossa aplicação movendo os nossos DTOs para um projeto compartilhado para que eles possam ser usados pela nossa aplicação front-end mais tarde.

## Adicionando o projeto ConferenceDTO
> Vamos começar criando o novo projeto compartilhado que irá conter os nossos objetos de transferência de dados (ou data transfer objects).

### Adicionando o projeto ConferenceDTO usando o Visual Studio
1. Se estiver usando o Visual Studio, clique com o botão direito na Solution e escolha *Add* / *New Project...*.
1. Escolha *.NET Standard* como tipo de projeto na esquerda e escolha o template *Class Library (.NET Standard)*. Nomeie o projeto como ConferenceDTO and clique em OK.
![](images/vs2019-create-dto-project.png)
1. Delete o arquivo `Class1.cs` deste novo projeto.
1. Clique com o botão direito no nó 'Dependencies' do projeto BackEnd, escolha "Add Reference..." e certifique-se de marcar o ConferenceDTO.

### Adicionando o projeto ConferenceDTO via linha de comando
1. Abra o prompt de comando e navegue para o diretório raiz `ConferencePlanner`.
1. Execute o seguinte commando: 
   ```console
   dotnet new classlib -o ConferenceDTO -f netstandard2.0
   ```
1. Next we'll need to add a reference to the ConferenceDTO project from the BackEnd project. From the command line, navigate to the BackEnd project directory and execute the following command:
1. A seguir, nós iremos precisar adicionar uma referência para o projeto ConferenceDTO no projeto BackEnd. Via linha de comando, navegue até o diretório do projeto BackEnd e execute o seguinte comando:
   ```console
   dotnet add reference ../ConferenceDTO
   ```
1. Adicione o projeto ConferenceDTO na Solution:
   ```
   dotnet sln add ConferenceDTO/ConferenceDTO.csproj
   ```

## Refatorando o modelo Speaker no projeto ConferenceDTO
1. Copie a classe `Speaker.cs` da aplicação *BackEnd* na raiz do novo projeto ConferenceDTO, e altere o namespace para `ConferenceDTO`.
1. As referências de anotações de dados (data annotations) devem "quebrar" neste ponto, para resolver isso, precisamos adicionar um pacote Nuget no projeto `ConferenceDTO`.
1. Adicione uma referência para o pacote NuGet `System.ComponentModel.Annotations` version `4.6.0`.
    > Isso pode ser feito via linha de comando executando `dotnet add package System.ComponentModel.Annotations --version 4.6.0`
1. Quando a restaurações dos pacotes completarem, você vai ver que as suas anotações de dados (data annotations) foram resolvidas agora.
1. Volte na aplicação *BackEnd* e modifique o código em `Speaker.cs` como o exemplo a seguir:
   ```csharp
   public class Speaker : ConferenceDTO.Speaker
   {
   }
   ```
1. Execute a aplicação e veja os dados dos Speakers usando a UI do Swagger para verificar que tudo ainda funciona.

## Adicionando os modelos restantes no ConferenceDTO

Temos muito mais modelos para adicioinar, e infelizmente isso é um pouco mecânico. Você pode copiar as seguintes classes manualmente, ou abrir a solução completa que é mostrada no final.

1. Crie uma classe `Attendee.cs` no projeto *ConferenceDTO* com o seguinte código:
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.ComponentModel.DataAnnotations;
   
   namespace ConferenceDTO
   {
       public class Attendee
       {
           public int Id { get; set; }
   
           [Required]
           [StringLength(200)]
           public virtual string FirstName { get; set; }
   
           [Required]
           [StringLength(200)]
           public virtual string LastName { get; set; }
   
           [Required]
           [StringLength(200)]
           public string UserName { get; set; }
           
           [StringLength(256)]
           public virtual string EmailAddress { get; set; }
       }
   }
   ```
1. Crie uma classe `Session.cs` com o seguinte código:
   ```csharp
   using System;
   using System.Collections;
   using System.Collections.Generic;
   using System.ComponentModel.DataAnnotations;
   
   namespace ConferenceDTO
   {
       public class Session
       {
           public int Id { get; set; }
   
           [Required]
           [StringLength(200)]
           public string Title { get; set; }
   
           [StringLength(4000)]
           public virtual string Abstract { get; set; }
   
           public virtual DateTimeOffset? StartTime { get; set; }
   
           public virtual DateTimeOffset? EndTime { get; set; }
   
           // Um prêmio para aqueles que souberem por que isto está escrito desta forma
           public TimeSpan Duration => EndTime?.Subtract(StartTime ?? EndTime ?? DateTimeOffset.MinValue) ?? TimeSpan.Zero;
   
           public int? TrackId { get; set; }
       }
   }
   ```
1. Crie uma classe `Track.cs` com o seguiunte código:
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.ComponentModel.DataAnnotations;
   
   namespace ConferenceDTO
   {
       public class Track
       {
           public int Id { get; set; }
   
           [Required]
           [StringLength(200)]
           public string Name { get; set; }
       }
   }
   ```

## Criando Modelos Derivados no projeto BackEnd
Nós não vamos criar os nossos modelos do EF diretamente a partir das classes em `ConferenceDTO`. Ao invés disso, nós vamos criar algumas classes compostas como o `SessionSpeaker`, pois elas serão mapeadas mais próximas daquilo com o que estará sendo trabalhado na aplicação.

Também vamos aproveitar essa oportunidade para renomear o diretório `Models` no projeto *BackEnd* para `Data` porque ele não contém mais apenas modelos.
1. Clique com o botão direitoo no diretótio `Models` e escolha `Rename`, altere o nome para `Data`.
    > Nota: Se você estiver no Visual Studio, você pode usar refatoração para renomear o namespace.
1. Adicione uma classe `SessionSpeaker.cs` no diretório `Data` com o seguinte código:
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using System.Threading.Tasks;
   
   namespace BackEnd.Data
   {
       public class SessionSpeaker
       {
           public int SessionId { get; set; }
   
           public Session Session { get; set; }
   
           public int SpeakerId { get; set; }
   
           public Speaker Speaker { get; set; }
       }
   }
   ```
1. Adicione uma classe `SessionAttendee.cs` com o seguinte código:
 
   ```csharp
   using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;

    namespace BackEnd.Data
    {
        public class SessionAttendee
        {
            public int SessionId { get; set; }

            public Session Session { get; set; }

            public int AttendeeId { get; set; }

            public Attendee Attendee { get; set; }
       }
   }
   ```
1. Adicioine uma classe `Attendee.cs` com o seguinte código:
   ```csharp
   using System;
   using System.Collections.Generic;
   
   namespace BackEnd.Data
   {
       public class Attendee : ConferenceDTO.Attendee
       {
           public virtual ICollection<SessionAttendee> SessionsAttendees { get; set; }
       }
   }
   ```
1. Adicione uma classe `Session.cs` com o seguinte código:
   ```csharp
   using System;
   using System.Collections;
   using System.Collections.Generic;
   
   namespace BackEnd.Data
   {
       public class Session : ConferenceDTO.Session
       {
           public virtual ICollection<SessionSpeaker> SessionSpeakers { get; set; }

           public virtual ICollection<SessionAttendee> SessionAttendees { get; set; }
   
           public Track Track { get; set; }
       }
   }
   ```
1. Adicione uma classe `Track.cs` com o seguinte código:
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.ComponentModel.DataAnnotations;

   namespace BackEnd.Data
   {
       public class Track : ConferenceDTO.Track
       {
           public virtual ICollection<Session> Sessions { get; set; }
       }
   }
   ```
1. Modifique a classe `Speaker.cs` que nós escrevemos anteriormente para fazendo as duas seguintes alterações: atualize o namespace para o mesmo nome do diretório que renomeamos, e adicione uma referência para a classe composta `SessionSpeaker`:
   ```csharp
   using System;
   using System.Collections.Generic;
   
   namespace BackEnd.Data
   {
       public class Speaker : ConferenceDTO.Speaker
       {
           public virtual ICollection<SessionSpeaker> SessionSpeakers { get; set; } = new List<SessionSpeaker>();
       }
   }
   ```

## Atualize o ApplicationDbContext
Certo, agora precisamos atualizar o nosso `ApplicationDbContext` para que o Entity Framework reconheça os nossos novos modelos.

1. Atualize o `ApplicationDbContext.cs` para usar o seguinte código:
   ```csharp
   using Microsoft.EntityFrameworkCore;

   namespace BackEnd.Data
   {
       public class ApplicationDbContext : DbContext
       {
           public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
               : base(options)
           {

           }

           protected override void OnModelCreating(ModelBuilder modelBuilder)
           {
               modelBuilder.Entity<Attendee>()
               .HasIndex(a => a.UserName)
               .IsUnique();

                // Many-to-many: Session <-> Attendee
                modelBuilder.Entity<SessionAttendee>()
                    .HasKey(ca => new { ca.SessionId, ca.AttendeeId });

                // Many-to-many: Speaker <-> Session
                modelBuilder.Entity<SessionSpeaker>()
                    .HasKey(ss => new { ss.SessionId, ss.SpeakerId });
           }

           public DbSet<Session> Sessions { get; set; }

           public DbSet<Track> Tracks { get; set; }

           public DbSet<Speaker> Speakers { get; set; }

           public DbSet<Attendee> Attendees { get; set; }
       }
   }
   ```
1. Resolva os erros após renomeado o `BackEnd.Models` para `BackEnd.Data`. Você também pode fazer isso usando um Procurar / Substituir (substituindo "BackEnd.Models" por "BackEnd.Data") ou você pode fazer um build e resolver os erros.
1. Certifique-se de que a aplicação agora completa o build sem erros.

## Adicione uma nova migração de banco de dados (database migration)

### Visual Studio: Console do Gerenciador de Pacotes (Package Manager Console)
1. Execute os seguintes comandos no Console do Gerenciador de Pacotes (especifique o projeto `BackEnd` na caixa de seleção)
   ```console
   Add-Migration Refactor
   Update-Database
   ```

### Via linha de comando
1. Execute os seguintes comandos na prompt de comando no diretório do projeto `BackEnd`:
   ```console
   dotnet ef migrations add Refactor
   dotnet ef database update
   ```
1. Agora respire fundo, execute a aplicação e navegue para `/swagger`. Você deve ver a UI do Swagger.

## Atualizando o API controller Speakers

1. Modifique a query para o método `GetSpeakers()` como mostrado abaixo:
   ```csharp
   var speakers = await _context.Speakers.AsNoTracking()
                           .Include(s => s.SessionSpeakers)
                               .ThenInclude(ss => ss.Session)
                           .ToListAsync();
   return speakers;
   ```
1. Embora que isso acima funcione, isso está retornando nossa classe modelo. Uma boa prática é retornar um modelo de classe de saída. Crie uma classe `SpeakerResponse.cs` no projeto `ConferenceDTO` com o seguinte código:
   ```csharp
   using System;
   using System.Collections.Generic;
   using System.Text;

   namespace ConferenceDTO
   {
       public class SpeakerResponse : Speaker
       {
           public ICollection<Session> Sessions { get; set; } = new List<Session>();
       }
   }
   ```
1. Agora nós vamos adicionar um método de utilidades para mapear essas classes entre si. No projeto de *BackEnd*, crie um diretório `Infrastructure`. Adicione uma classe de nome `EntityExtensions.cs` com o seguinte código de mapeameto:
   ```csharp
   using BackEnd.Data;
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using System.Threading.Tasks;

   namespace BackEnd.Data
   {
       public static class EntityExtensions
       {
           public static ConferenceDTO.SpeakerResponse MapSpeakerResponse(this Speaker speaker) =>
               new ConferenceDTO.SpeakerResponse
               {
                   Id = speaker.Id,
                   Name = speaker.Name,
                   Bio = speaker.Bio,
                   WebSite = speaker.WebSite,
                   Sessions = speaker.SessionSpeakers?
                       .Select(ss =>
                           new ConferenceDTO.Session
                           {
                               Id = ss.SessionId,
                               Title = ss.Session.Title
                           })
                       .ToList()
               };
       }
   }
   ```
1. Agora podemos atualizar o método `GetSpeakers()` do *SpeakersController* para que ele retorne o nosso modelo de saída. Atualize as linhas de código de forma semelhante ao método como mostrado a seguir:
   ```csharp
   [HttpGet]
   public async Task<ActionResult<List<ConferenceDTO.SpeakerResponse>>> GetSpeakers()
   {
       var speakers = await _context.Speakers.AsNoTracking()
                                       .Include(s => s.SessionSpeakers)
                                           .ThenInclude(ss => ss.Session)
                                       .Select(s => s.MapSpeakerResponse())
                                       .ToListAsync();
       return speakers;
   }
   ```
1. Atualize o método `GetSpeaker()` para usar o nosso modelo de saída mapeado como a seguir:
   ```csharp
   [HttpGet("{id}")]
   public async Task<ActionResult<ConferenceDTO.SpeakerResponse>> GetSpeaker(int id)
   {
       var speaker = await _context.Speakers.AsNoTracking()
                                       .Include(s => s.SessionSpeakers)
                                           .ThenInclude(ss => ss.Session)
                                       .SingleOrDefaultAsync(s => s.Id == id);
       if (speaker == null)
       {
           return NotFound();
       }
       return speaker.MapSpeakerResponse();
   }
   ```
1. Remova as outras actions (`PutSpeaker`, `PostSpeaker`, `DeleteSpeaker`), no `SpeakersController`.

## Adicionando os API Controllers e DTOs restantes

1. Adicione as seguintes classes DTO de saída contidas [na pasta save point](/save-points/2-BackEnd-completed/ConferencePlanner/ConferenceDTO)
   - `AttendeeResponse`
   - `SessionResponse`
   - `ConferenceResponse`
   - `TrackResponse`
   - `TagResponse`
1. Atualize a classe `EntityExtensions` com os métodos `MapSessionResponse` e `MapAttendeeResponse` da [pasta save point](/save-points/2b-BackEnd-completed/ConferencePlanner/BackEnd/Infrastructure)
1. Copie os seguintes controllers da [pasta save point](/save-points/2b-BackEnd-completed/ConferencePlanner/BackEnd/Controllers) no diretório do projeto atual `BackEnd/Controllers`:
   - `SessionsController`
   - `AttendeesController`

## Adicionando suporte a Conference Upload
1. Copy the `DataLoader.cs` class from [here](/src/BackEnd/Data/DataLoader.cs) into the `Data` directory of the `BackEnd` project.
1. Copie as classes `SessionizeLoader.cs` e `DevIntersectionLoader.cs` [daqui](/src/BackEnd/Data/) para o diretório do projeto atual `/src/BackEnd/Data/`. 
    > Nota: Temos carregadores de dados das duas séries de conferências onde este workshop foi mais apresentado; você pode atualizar isso para conectar seu próprio formato de arquivo de conferência.
1. Para melhorar a interface do usuário para upload, ative a opção de exibir enumerações como strings, alterando `AddSwaggerGen` em `Startup.cs` para o seguinte:
    ```c#
    services.AddSwaggerGen(options =>
    {
        options.SwaggerDoc("v1", new OpenApiInfo { Title = "Conference Planner API", Version = "v1" });
        options.DescribeAllEnumsAsStrings();
    });
    ```
1. Execute o aplicativo para ver os dados atualizados pela UI do Swagger.
1. Use the Swagger UI to upload [NDC_Sydney_2019.json](/src/BackEnd/Data/Import/NDC_Sydney_2019.json) to the `/api/Sessions/upload` API.
1. Use a UI do Swagger para fazer o upload do [NDC_Sydney_2019.json](/src/BackEnd/Data/Import/NDC_Sydney_2019.json) para a API `/api/Sessions/upload`.

**Próximo**: [Sessão #3 - Front-end](3.%20Add%20front-end%2C%20render%20agenda%2C%20set%20up%20front-end%20models.md) | **Anterior**: [Sessão #1 - Setup, basic EF model](/docs/1.%20Create%20BackEnd%20API%20project.md)
