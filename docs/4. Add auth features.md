# Adicionar habilidade de login no web site

Neste módulo nós iremos adicionar funcionalidades para que o usuário possa se registrar e fazer sing-in na web app do front-end com um nome de usuário e senha. Faremos isso usando o ASP.NET Core Identity.

## Fazendo scaffold no ASP.NET Core Identity e na UI padrão
> Vamos começar fazendo scaffold no Identity com a experiência padrão na web app do front-end.

### Adicionando Identity usando o Visual Studio
1. Clique com o botão direito do mouse no projeto FrontEnd na Solution Explorer e escolha "Add" e então "New Scaffolded Item..."
1. Escolha a categoria "Identity" do lado esquerdo do menu e então escolha "Identity" na lista e clique no botão "Add".
1. Na caixa de diálogo "Add Identity", clique no botão '+' para adicionar uma classe de contexto de dados. Chamaremos essa classe de `FrontEnd.Data.IdentityDbContext`.
1. No mesmo diálogo, clique no botão '+' e adicione uma classe de usuário, que chamaremos de `FrontEnd.Data.User`.
1. Clique no botão "Add".

### Adicionando Identity usando a linha de comando
1. Abra o prompt de comando na pasta do projeto **FrontEnd**
1. Se você ainda não fez isso, instale a ferramenta de linha de comando de scaffolding.
   ```
   dotnet tool install -g dotnet-aspnet-codegenerator
   ```
1. Adicione o pacote `Microsoft.VisualStudio.Web.CodeGeneration.Design` version `3.0.0` no projeto.
   ```
   dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design --version 3.0.0
   ```
1. Execute esse comando para gerar o código para usar Identity.
   ```
   dotnet aspnet-codegenerator identity --dbContext FrontEnd.Data.IdentityDbContext --userClass FrontEnd.Data.User --useDefaultUI
   ```

## Organize os arquivos criados recentemente
> Note os novos arquivos que foram adicionados ao projeto na pasta "Areas/Identity". Nós vamos alterar um pouco isso para corresponder com as convenções desse projeto.

1. Exclua o arquivo `_ValidationScriptsPartial.cshtml`na pasta `/Areas/Identity/Pages`, pois nós já temos um em nossa pasta original do projeto.
1. Exclua o arquivo `ScaffoldingReadme.txt`.

## Adicione os links do Identity no header no site

> O sistema do Identity onde foi aplicado o scaffold, inclue uma *Razor view* parcial que contém a UI correspondente ao Identity para o header do site, como por exemplo os links para Login e Registro, nome de usuário uma vez logado, etc. Vamos adicionar uma chamda para essa *view* parcial a partir do próprio layout da página:

1. Abra o arquivo `_Layout.cshtml` e encontre a seguinte linha: `<div class="navbar-collapse collapse d-sm-inline-flex flex-sm-row-reverse">`
1. Imediatamente após essa linha, adicione uma chamada para o `_LoginPartial.cshtml` recentemente adicionado usando a Tag Helper `<partial />`:
    ``` html
    <div class="navbar-collapse collapse d-sm-inline-flex flex-sm-row-reverse">
        <partial name="_LoginPartial" />
        <ul class="navbar-nav flex-grow-1">
            <li class="nav-item">
                <a class="nav-link text-dark" asp-area="" asp-page="/Index">Home</a>
            </li>
        </ul>
    </div>
    ```

## Atualize a aplicação para oferecer suporte à usuários administradores
> O Identity oferece suporte para simples customizações de classes representando usuários, e ao usar o Entity Framework Core padrão, essas mudanças resultarão em atualizações de schema automáticos para armazenamento. Nós também podemos customizar a UI padrão do Identity simplesmente aplicando *scaffolding* nas páginas que queremos alterar. Vamos adicionar a abilidade de criar um usuário administrador.

### Customize a classe `User` para oferecer suporte para usuários administradores
1. Abra a classe `User` criada recentemente na pasta `/Areas/Identity/Data`
1. Adicione uma propriedade `bool` para indicar quando que o usuário é um administrador:
    ``` c#
    public class User : IdentityUser
    {
        public bool IsAdmin { get; set; }
    }
    ```

### Gerar a migração do Entity Framework para o nosso schema Identity

#### Visual Studio: Console do Gerenciador de Pacotes

1. No Visual Studio, escolha Tools -> NuGet Package Manager -> Package Manager Console

1. Execute os seguintes comandos no Console do Gerenciador de Pacotes
   ```console
   Add-Migration CreateIdentitySchema
   Update-Database
   ```

#### Linha de comando

1. Execute os seguintes comandos no prompt de comando:
    ```console
    dotnet build
    dotnet ef migrations add CreateIdentitySchema
    dotnet ef database update
    ```

### Adicione o middleware de autenticação
> Precisamos garantir que o *pipeline* de solicitação contém o *middleware* de autenticação que representa os recursos que 
queremos autorizar potencialmente, como por exemplo Páginas Razor
1. Abra o arquivo `Startup.cs`
1. No método `configure`, adicione uma chamada para adicionar o *middleware* de Autenticação antes do *middleware* de Autorização:
    ``` c#
    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        else
        {
            app.UseExceptionHandler("/Error");
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseStaticFiles();

        app.UseRouting();

        app.UseAuthentication();
        app.UseAuthorization();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapRazorPages();
        });
    }
    ```

### Criando um usuário administrador
> Vamos fazer com que o site permita a criação de um usuário administrador quando ainda não existir um. O primeiro usuário a acessar o site será considerado administrador.

1. Crie uma nova classe `AdminService` na pasta `Services`. Essa classe será responsável por gerenciar a geração da chave de criação e rastrear se o site deve permitir a criação de usuários administrativos.
    ``` c#
    public class AdminService
    {
        private readonly IdentityDbContext _dbContext;

        private bool _adminExists;

        public AdminService(IdentityDbContext dbContext)
        {
            _dbContext = dbContext;
        }

        public async Task<bool> AllowAdminUserCreationAsync()
        {
            if (_adminExists)
            {
                return false;
            }
            else
            {
                if (await _dbContext.Users.AnyAsync(user => user.IsAdmin))
                {
                    // There are already admin users so disable admin creation
                    _adminExists = true;
                    return false;
                }

                // There are no admin users so enable admin creation
                return true;
            }
        }
    }
    ```
1. Vamos extrair uma interface dessa classe e vamos chama-la de `IAdminService`
    ``` c#
    public interface IAdminService
    {
        Task<bool> AllowAdminUserCreationAsync();
    }
    ```
1. Na classe `Startup`, modifique o método `ConfigureServices` para adicionar o novo serviço ao container de injeção de dependências:
    ``` c#
    services.AddSingleton<IAdminService, AdminService>();
    ```

> Precisamos sobrescrever a página padrão de Registro para habilitar a criação da conta administrativa quando o primeiro usuário for resgistrado.
1. Execute o processo de scaffolding do Identity novamente, mas dessa vez escolha a página `Account\Register` na lista de arquivos para sobrescrever e escolha o `IdentityDbContext (FrontEnd.Data)`
   * Na lina de comando, execute
     ```
     dotnet aspnet-codegenerator identity --dbContext FrontEnd.Data.IdentityDbContext --files Account.Register
     ```
1. Atualize a classe `RegisterModel` no arquivo `Register.cshtml.cs` para aceitar `IAdminService` como parâmetro e atribua ela a um campo local:

    ``` c#
    [AllowAnonymous]
    public class RegisterModel : PageModel
    {
        private readonly SignInManager<User> _signInManager;        
        private readonly UserManager<User> _userManager;
        private readonly ILogger<RegisterModel> _logger;
        private readonly IEmailSender _emailSender;
        private readonly IAdminService _adminService;

        public RegisterModel(
            UserManager<User> userManager,
            SignInManager<User> signInManager,
            ILogger<RegisterModel> logger,
            IEmailSender emailSender,
            IAdminService adminService)
        {
            _userManager = userManager;
            _signInManager = signInManager;
            _logger = logger;
            _emailSender = emailSender;
            _adminService = adminService;
        }

        ...
    ```

1. Adicione código no `OnPostAsync` que marca o novo usuário como um administrador se o `IAdminService.AllowAdminUserCreationAsync` retornar verdadeiro antes de criar o uusuário:
    ``` c#
    if (await _adminService.AllowAdminUserCreationAsync())
    {
        // Set as admin user
        user.IsAdmin = true;
    }

    var result = await _userManager.CreateAsync(user, Input.Password);
    ```
1. Atualize o código que faz log de uma mensagem quando usuários são criados para indicar quando um usuário administrador é criado:
    ``` c#
    if (user.IsAdmin)
    {
        _logger.LogInformation("Admin user created a new account with password.");
    }
    else
    {
        _logger.LogInformation("User created a new account with password.");
    }
    ```

> Se você executar a aplicação neste ponto, você verá uma execeção afirmando que você não pode injetar um tipo scoped num tipo 
registrado como singleton. Isso é o sistema de DI (Injeção de Dependência) te protegendo de um anti-pattern comum que pode ocorrer ao usar containers IoC (Inversão de Controle). Vamos corrigir o `AdminService` para usar o `IdentityDbContext` scoped corretamente.

1. Abra o arquivo `AdminService.cs` e altere o código para aceitar um `IServiceProvider` ao invés de `IdentityDbContext` no construtor:
    ``` csharp
    public class AdminService : IAdminService
    {
        private readonly IServiceProvider _serviceProvider;

        private bool _adminExists;

        public AdminService(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }

        // ...
    ```
1. Agora atualize o método `AllowAdminUserCreationAsync` para criar um escopo de serviço para que possamos solicitar uma instância do `IdentityDbContext` dentro do escopo de contexto:
    ``` csharp
    public async Task<bool> AllowAdminUserCreationAsync()
    {
        if (_adminExists)
        {
            return false;
        }
        else
        {
            using (var scope = _serviceProvider.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<IdentityDbContext>();

                if (await dbContext.Users.AnyAsync(user => user.IsAdmin))
                {
                    // There are already admin users so disable admin creation
                    _adminExists = true;
                    return false;
                }

                // There are no admin users so enable admin creation
                return true;
            }
        }
    }
    ```
1. Execute a aplicação novamente e agora você não deve ver uma execeção.

# Adicionando uma sessão de administrador

## Adicionando uma política de administração

> Invés de acessar o banco de dados para buscar um usuário cada vez que a aplicação precisar verificar se um usuário é um administrador, nós podemos ler essa informação uma vez quando o usuário se *logar*, e então armazenar isso como uma *claim* adicional na identidade do usuário. Precisamos adicionar também uma política de autorização na aplicação que corresponda à essa *claim*, assim nós podemos usar isso para proteger os recursos que nós queremos que apenas usuários administradores acessem.

1. Adicione uma nova classe `ClaimsPrincipalFactory.cs` na pasta `/Areas/Identity` e adicione código que adiciona uma *claim* de administrador para usuários que são administradores:
    ``` c#
    public class ClaimsPrincipalFactory : UserClaimsPrincipalFactory<User>
    {
        private readonly IApiClient _apiClient;

        public ClaimsPrincipalFactory(IApiClient apiClient, UserManager<User> userManager, IOptions<IdentityOptions> optionsAccessor)
            : base(userManager, optionsAccessor)
        {
            _apiClient = apiClient;
        }

        protected override async Task<ClaimsIdentity> GenerateClaimsAsync(User user)
        {
            var identity = await base.GenerateClaimsAsync(user);

            if (user.IsAdmin)
            {
                identity.MakeAdmin();
            }

            return identity;
        }
    }
    ```
1. Adicione uma nova classe `AuthHelpers.cs` na pasta `Infrastructure` e adicione os seguintes métodos de ajudar para a leitura de definição de *claim* de administrador:
    ``` c#
    namespace FrontEnd.Infrastructure
    {
        public static class AuthConstants
        {
            public static readonly string IsAdmin = nameof(IsAdmin);
            public static readonly string IsAttendee = nameof(IsAttendee);
            public static readonly string TrueValue = "true";
        }
    }

    namespace System.Security.Claims
    {
        public static class AuthnHelpers
        {
            public static bool IsAdmin(this ClaimsPrincipal principal) =>
                principal.HasClaim(AuthConstants.IsAdmin, AuthConstants.TrueValue);

            public static void MakeAdmin(this ClaimsPrincipal principal) =>
                principal.Identities.First().MakeAdmin();

            public static void MakeAdmin(this ClaimsIdentity identity) =>
                identity.AddClaim(new Claim(AuthConstants.IsAdmin, AuthConstants.TrueValue));
        }
    }

    namespace Microsoft.Extensions.DependencyInjection
    {
        public static class AuthzHelpers
        {
            public static AuthorizationPolicyBuilder RequireIsAdminClaim(this AuthorizationPolicyBuilder builder) =>
                builder.RequireClaim(AuthConstants.IsAdmin, AuthConstants.TrueValue);
        }
    }
    ```

1. Registre a fábrica customizada `UserClaimsPrincipalFactory<User>` na classe `IdentityHostingStartup`:

    ```csharp
    services.AddDefaultIdentity<User>()
            .AddEntityFrameworkStores<IdentityDbContext>()
            .AddClaimsPrincipalFactory<ClaimsPrincipalFactory>();
    ```
1. Adicione serviços de autorização com uma política de administrador no método `ConfigureServices()` da `Startup.cs` que usa os métodos de ajudar que acabaram de ser adicionados e exigem a *claim* de administrador:

    ```csharp
    services.AddAuthorization(options =>
    {
        options.AddPolicy("Admin", policy =>
        {
            policy.RequireAuthenticatedUser()
                  .RequireIsAdminClaim();
        });
    });
    ```
1. Adicione `System.Security.Claims` a lista de usings no `Index.cshtml.cs`, e então use o método de ajuda no modelo de página para determinar se o usuário em questão é um administrador.

    ```csharp
    public bool IsAdmin { get; set; }

    public async Task OnGetAsync(int day = 0)
    {
        IsAdmin = User.IsAdmin();

        // More stuff here
        // ...
    }
    ```
1. Na página razor `Index`, adicione um link de edição que permita que administradores editem sessões. Você vai adicionar o seguinte código logo depois do loop `foreach` da sessão:

    ```html
	<div class="card-footer">
	    <ul class="list-inline mb-0">
		@foreach (var speaker in session.Speakers)
		{
		    <li class="list-inline-item">
			    <a asp-page="Speaker" asp-route-id="@speaker.ID">@speaker.Name</a>
		    </li>
		}
		@if (Model.IsAdmin)
		{
		    <li>
			    <a asp-page="/Admin/EditSession" asp-route-id="@session.Id" class="btn btn-default btn-xs">Edit</a>
		    </li>
		}
	    </ul>
	</div>
    ```
1. Adicione uma subpasta `Admin` na pasta `Pages` e então adicione uma página razor `EditSession.cshtml` e um modelo de página `EditSession.cshtml.cs` para ela.
1. A seguir, nós iremos proteger a página na pasta `Admin` com uma política de administrador fazendo a seguinte alteração na chamada `services.AddRazorPages()` do `Startup.ConfigureServices`:

   ```csharp
   services.AddRazorPages(options =>
   {
       options.Conventions.AuthorizeFolder("/Admin", "Admin");
   });
   ```

## Adicione um formulário para editar uma sessão
1. Altere o `EditSession.cshtml.cs` para renderizar a sessão no formulário de edição:

   ```csharp
   public class EditSessionModel : PageModel
   {
      private readonly IApiClient _apiClient;

      public EditSessionModel(IApiClient apiClient)
      {
         _apiClient = apiClient;
      }

      public Session Session { get; set; }

      public async Task OnGetAsync(int id)
      {
         var session = await _apiClient.GetSessionAsync(id);
         Session = new Session
         {
             Id = session.Id,
             TrackId = session.TrackId,
             Title = session.Title,
             Abstract = session.Abstract,
             StartTime = session.StartTime,
             EndTime = session.EndTime
         };
      }
   }
   ```

1. Adicione a rota "{id}" no formulário `EditSession.cshtml`:

    ```html
    @page "{id}"
    @model EditSessionModel
    ```

1. Adicione o seguinte formmulário de edição no `EditSession.cshtml`:

   ```html
   <h3>Edit Session</h3>

   <form method="post" class="form-horizontal">
       <div asp-validation-summary="All" class="text-danger"></div>
       <input asp-for="Session.Id" type="hidden" />
       <input asp-for="Session.TrackId" type="hidden" />
       <div class="form-group">
           <label asp-for="Session.Title" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <input asp-for="Session.Title" class="form-control" />
               <span asp-validation-for="Session.Title" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <label asp-for="Session.Abstract" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <textarea asp-for="Session.Abstract" class="form-control"></textarea>
               <span asp-validation-for="Session.Abstract" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <label asp-for="Session.StartTime" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <input asp-for="Session.StartTime" class="form-control" />
               <span asp-validation-for="Session.StartTime" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <label asp-for="Session.EndTime" class="col-md-2 control-label"></label>
           <div class="col-md-10">
               <input asp-for="Session.EndTime" class="form-control" />
               <span asp-validation-for="Session.EndTime" class="text-danger"></span>
           </div>
       </div>
       <div class="form-group">
           <div class="col-md-offset-2 col-md-10">
               <button type="submit" class="btn btn-primary">Save</button>
               <button type="submit" asp-page-handler="Delete" class="btn btn-danger">Delete</button>
           </div>
       </div>
   </form>

   @section Scripts {
        <partial name="_ValidationScriptsPartial" />
   }
   ```
1. Adicione código para menipular os botões de ação `Save` e `Delete` no `EditSession.cshtml.cs`:

   ```csharp
   public async Task<IActionResult> OnPostAsync()
   {
      if (!ModelState.IsValid)
      {
          return Page();
      }

      await _apiClient.PutSessionAsync(Session);

      return Page();
   }

   public async Task<IActionResult> OnPostDeleteAsync(int id)
   {
      var session = await _apiClient.GetSessionAsync(id);

      if (session != null)
      {
          await _apiClient.DeleteSessionAsync(id);
      }

      return Page();
   }
   ```

1. Adicione um atributo `[BindProperty]` na propriedade `Session` no `EditSession.cshtml.cs` para garantir que as propriedades serão vinculadas na postagem do formulário:
   ```csharp
   [BindProperty]
   public Session Session { get; set; }
   ```

1. O formulário deve estar completamente funcional.

## Adicione mensagem de sucesso na postagem do formulário e use o padrão [PRG](https://en.wikipedia.org/wiki/Post/Redirect/Get)

1. Adicione uma propriedade `Message` decorada com `TempData` e uma propriedade `ShowMessage` no `EditSession.cshtml.cs`:

   ```csharp
   [TempData]
   public string Message { get; set; }

   public bool ShowMessage => !string.IsNullOrEmpty(Message);
   ```

1. Defina uma mensagem de sucesso nos métodos `OnPostAsync` e `OnPostDeleteAsync` e altere `Page()` para `RedirectToPage()`:

   ```csharp
   public async Task<IActionResult> OnPostAsync()
   {
      if (!ModelState.IsValid)
      {
          return Page();
      }
      
      Message = "Session updated successfully!";

      await _apiClient.PutSessionAsync(Session);

      return RedirectToPage();
   }

   public async Task<IActionResult> OnPostDeleteAsync(int id)
   {
      var session = await _apiClient.GetSessionAsync(id);

      if (session != null)
      {
          await _apiClient.DeleteSessionAsync(id);
      }
      
      Message = "Session deleted successfully!";

      return RedirectToPage("/Index");
   }
   ```

1. Atualize o `EditSession.cshtml` para exibir a mensagem após a postagem. Adicione o seguinte código logo abaixo da tag `<h3>` no topo:

   ```html
   @if (Model.ShowMessage)
   {
       <div class="alert alert-success alert-dismissible" role="alert">
           <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span>   </button>
           @Model.Message
       </div>
   }
   ```

> Propriedades do tipo TempData-backed também fluem entre páginas, sendo assim nós podemos atualizar a página Index para exibir o valor da mensagem também, quando a sessão for deletada por exemplo

1. Copie a marcação de exibição da mensagem no topo do arquivo `EditSession.cshtml` para o topo do arquivo `Index.cshtml`:
    ``` html
    @if (Model.ShowMessage)
    {
        <div class="alert alert-success alert-dismissible" role="alert">
            <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span>   </button>
            @Model.Message
        </div>
    }
    ```
1. Copie as propriedades do arquivo da classe de modelo de página `EditSession.cshtml.cs` para o modelo de página `Index.cshtml.cs` também:
    ``` csharp
    [TempData]
   public string Message { get; set; }

   public bool ShowMessage => !string.IsNullOrEmpty(Message);
    ```
1. Faça um *rebuild* e execute a aplicação e então apague uma sessão e observe o redirecionamente para a página inicial e exiba a mensagem de sucesso

## Crie uma Tag helper com os requisitos para as configurações de autorização dos elementos de UI
Atualmente nós estamos usando blocos `if` para determinar onde exibir partes da UI com base nas políticas de autorização do usuário. Nós podemos simplificar esse código criando um [Tag Helper](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro) customizado.

1. Crie uma nova pasta chamada `TagHelpers` na raiz do projeto *FrontEnd*. Clique com o botão direito na pasta, escolha *Add* / *New Item...* / *Razor Tag Helper*. Nomeie a Tag Helper de `AuthzTagHelper.cs`.
1. Modifique o atributo `HtmlTargetElement` para vincular todos os elementos com um atributo "authz":
   ```csharp
   [HtmlTargetElement("*", Attributes = "authz")]
   ```
1. Crie um atributo adicional `HtmlTargetElement` para vincular todos os elementos com um atributo "authz-policy":
   ```csharp
   [HtmlTargetElement("*", Attributes = "authz-policy")]
   ```
1. Faça uma injeção do `AuthorizationService` como mostrado a seguir:
   ```csharp
   private readonly IAuthorizationService _authzService;

   public AuthzTagHelper(IAuthorizationService authzService)
   {
       _authzService = authzService;
   }
   ```
1. Adicione as seguintes propriedades as quais representarão os atributos `auth` e `authz` que nós estamos vinculando:
   ```csharp
   [HtmlAttributeName("authz")]
   public bool RequiresAuthentication { get; set; }

   [HtmlAttributeName("authz-policy")]
   public string RequiredPolicy { get; set; }
   ```
1. Adicione uma propriedade `ViewContext`:
   ```csharp
   [ViewContext]
   public ViewContext ViewContext { get; set; }
   ```
1. Marque o método `ProcessAsync` como `async`.
1. Adicione o seguinte código no método `ProcessAsync`:
   ```csharp
   public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
   {
       var requiresAuth = RequiresAuthentication || !string.IsNullOrEmpty(RequiredPolicy);
       var showOutput = false;

       if (context.AllAttributes["authz"] != null && !requiresAuth && !ViewContext.HttpContext.User.Identity.IsAuthenticated)
       {
           // authz="false" & user isn't authenticated
           showOutput = true;
       }
       else if (!string.IsNullOrEmpty(RequiredPolicy))
       {
           // authz-policy="foo" & user is authorized for policy "foo"
           var authorized = false;
           var cachedResult = ViewContext.ViewData["AuthPolicy." + RequiredPolicy];
           if (cachedResult != null)
           {
               authorized = (bool)cachedResult;
           }
           else
           {
               var authResult = await _authzService.AuthorizeAsync(ViewContext.HttpContext.User, RequiredPolicy);
               authorized = authResult.Succeeded;
               ViewContext.ViewData["AuthPolicy." + RequiredPolicy] = authorized;
           }

           showOutput = authorized;
       }
       else if (requiresAuth && ViewContext.HttpContext.User.Identity.IsAuthenticated)
       {
           // authz="true" & user is authenticated
           showOutput = true;
       }

       if (!showOutput)
       {
           output.SuppressOutput();
       }
   }
   ```
1. Registre a nova Tag Helper no arquivo `_ViewImports.cshtml`:
   ```html
   @namespace FrontEnd.Pages
   @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
   @addTagHelper *, FrontEnd
   ```
1. Agora nós podemos atualizar a página `Index.cshtml` para substituir o bloco `if` que controla a exibição do botão de edição com código declarativo usando a nossa nova Tag Helper. Remova o bloco `if` e adicione `authz="true` na tag `<a>` que exibe o botão de edição:
   ```html
	<div class="card-footer">
	    <ul class="list-inline mb-0">
		@foreach (var speaker in session.Speakers)
		{
		    <li class="list-inline-item">
			<a asp-page="Speaker" asp-route-id="@speaker.Id">@speaker.Name</a>
		    </li>
		}
        </ul>
        <a authz-policy="Admin" asp-page="/Admin/EditSession" asp-route-id="@session.Id" class="btn btn-default btn-xs">Edit</a>
	</div>
    ```
    
**Próximo**: [Sessão #5 - Adicionar Agenda](5.%20Add%20personal%20agenda.md) | **Anterior**: [Sessão #3 - Adicionar front-end](3.%20Add%20front-end%2C%20render%20agenda%2C%20set%20up%20front-end%20models.md)
