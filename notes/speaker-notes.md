# Sessão 1

- Intro
    - Mostre a inicialização da API, explique que a configuração é injetada na classe Startup
    - Explique o MVC CompatibilityVersion
    - Mostre o ValuesController
- Noções básicas do EntityFramework
    - Explique que um DbContext mapeia para o banco de dados
    - Explique que um DbSet mapeia para uma tabela
    - Explique como as DataAnnotations são usadas para modelar o banco de dados
    - Explique como as migrações funcionam em alto nível
        - Há uma migração para cima e uma migração para baixo (mas ninguém nunca usa migrações para baixo na produção)
        - EF armazena o estado atual do modelo no banco de dados e o compara ao modelo na origem
    - Explique como a conexão do DbContext o torna disponível em qualquer lugar.
- Scaffolding
    - Mostrar suporte ao Scaffolding no VS
    - Mostrar a versão da linha de comandos
- APIs
    - Discuta brevemente o código do Scaffolding
    - Explique por que o ActionResult<T> existe e como era o código antigo
    - Explique o novo API controller attribute
    - Mencione a classe base ControllerBase e como ela possui menos métodos que o Controller
- Swagger
    - Explique o que é arrogância e como é usada
    - Fale sobre a biblioteca Swashbuckle e mencione o NSwag (um modelo alternativo)
    - Fale sobre o novo suporte à geração do swagger em tempo de build que está chegando
    - Fale sobre a ordem do middleware e como o redirecionamento funciona
    - Discuta e mostre a interface do usuário do swagger

# Sessão 2

- Intro
    - Explique que estamos criando uma biblioteca de classes para compartilhar os tipos de modelo e as definições de atributo entre os aplicativos front-end e back-end.
    - Explique quais partes da estrutura consomem os data annotations
        - APIs usam para validação
        - É usado como parte da definição do swagger
        - É usado para gerar lógica do lado do cliente
        - É usado para lidar com a lógica do lado do servidor
        - É usado como parte do DDL gerado

- EntityFramework
    - Modelando um banco de dados relacional usando EntityFramework
        - Mostre quantos muitos-para-muitos são expressados em uma classe de modelo EF (a tabela de middleware deve ser explicitamente modelada)
        - Explique como cada uma das classes faz referência a outras entidades para chaves estrangeiras
            - Essa é uma das razões pelas quais é ruim retornar diretamente os modelos EF
        - Mostre como o modelo EF pode ser modificado no DbContext
            - Mostre como Session tem uma propriedade computada e mostre como isso é tratado no ModelBuilder
            - Mostre como configurar unique indexes
            - Mostre o intellisense para várias model builder APIs
            - Explique que o ModelBuilder pode ser usado para descrever completamente as entidades em vez de usar atributos
    - Migrations
        - Mostrar como os atributos afetam o código de migração (e mostrar DDL)
        - Mostrar a criação de um script db
    - Queries
        - Explique o AsNoTracking e por que ele é bom para cenários da web
        - Explique que o EF 2.1 suporta carregamento lento e que está desativado por padrão (https://docs.microsoft.com/en-us/ef/ef6/querying/related-data#lazy-loading)
            - Aponte para o documento de práticas recomendadas para carregamento lento e serialização (https://docs.microsoft.com/en-us/ef/ef6/querying/related-data#turn-lazy-loading-off-for-serialization)
        - Modifique as consultas EF e mostre o carregamento ágil com o Include (explique como ele evita os problemas N+1 com o carregamento lento)
        - Mostre como visualizar as consultas EF geradas nos logs
- APIs
    - Mostre como o novo controlador de API remove o clichê (mostre a antiga oficina 2.1)
        - FromBody é inferido
        - FromRoute é inferido se o parâmetro route corresponder à definição de rota
        - ModelState.IsValue é removido
    - Mostre as entidades no swagger, mostre como ele tem todo o gráfico de objetos porque estamos retornando o modelo EF
    - Explique por que o ActionResult<T> existe e como era o código antigo
    - Explique como o ActionResult<T> ajuda a gerar um swagger melhor
    - Mostre o swagger.json e a sintaxe para declarar coisas como respostas, etc.
    - Mostre como os detalhes do problema funcionam para erros 400
    - Mostre os analisadores de convenções da API
    - Discutir validação automática de modelo
- Diversos
    - Discuta como funciona o upload de arquivos
    - Explique a diferença entre o IFormFile (com buffer) e o MultipartReader de streaming (https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-2.2)
	